{% extends "base.html" %}
{% block content %}
<style>
  .speaker-mapping-container {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 16px;
    margin-top: 10px;
  }
  
  .speaker-mapping-row {
    display: grid;
    grid-template-columns: 140px 1fr 80px;
    gap: 12px;
    align-items: center;
    margin-bottom: 10px;
    background: white;
    padding: 10px 14px;
    border-radius: 6px;
    border: 1px solid #e0e0e0;
  }
  
  .speaker-mapping-row:hover {
    border-color: #2196F3;
    box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15);
  }
  
  .speaker-label {
    font-family: ui-monospace, monospace;
    font-size: 13px;
    font-weight: 600;
    color: #555;
    background: #f0f0f0;
    padding: 6px 10px;
    border-radius: 4px;
    text-align: center;
  }
  
  .speaker-input {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    transition: all 0.2s;
  }
  
  .speaker-input:focus {
    outline: none;
    border-color: #2196F3;
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
  }
  
  .speaker-count {
    font-size: 12px;
    color: #888;
    text-align: right;
  }
  
  .mapping-empty {
    text-align: center;
    padding: 30px;
    color: #999;
    font-style: italic;
  }
  
  .advanced-toggle {
    margin-top: 12px;
    font-size: 12px;
    color: #666;
    cursor: pointer;
    user-select: none;
  }
  
  .advanced-toggle:hover {
    color: #2196F3;
  }
  
  .json-editor {
    display: none;
    margin-top: 10px;
  }
  
  .json-editor.show {
    display: block;
  }
  
  #speaker_toast {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(33, 150, 243, 0.95);
    color: white;
    padding: 12px 18px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  
  /* Diarization blocks styling (like transcription) */
  .blocklist {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .seg {
    padding: 12px 16px;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .seg:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    transform: translateY(-1px);
  }
  
  .seg-active {
    border-color: #2196F3;
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
  }
  
  .seg-time {
    font-size: 11px;
    color: #888;
    margin-bottom: 4px;
    font-family: ui-monospace, monospace;
  }
  
  .seg-speaker {
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 6px;
    padding: 3px 8px;
    border-radius: 4px;
    display: inline-block;
  }
  
  .seg-text {
    font-size: 14px;
    line-height: 1.5;
    color: #333;
  }
  
  /* Speaker colors - pastel palette */
  .speaker-0 { background-color: #E3F2FD; } /* Light Blue */
  .speaker-1 { background-color: #F3E5F5; } /* Light Purple */
  .speaker-2 { background-color: #E8F5E9; } /* Light Green */
  .speaker-3 { background-color: #FFF3E0; } /* Light Orange */
  .speaker-4 { background-color: #FCE4EC; } /* Light Pink */
  .speaker-5 { background-color: #F1F8E9; } /* Light Lime */
  .speaker-6 { background-color: #E0F2F1; } /* Light Teal */
  .speaker-7 { background-color: #FFF9C4; } /* Light Yellow */
  .speaker-8 { background-color: #FFEBEE; } /* Light Red */
  .speaker-9 { background-color: #EDE7F6; } /* Light Deep Purple */
  
  /* Responsywny grid dla trybu/jƒôzyka/modelu */
  .di-config-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 10px;
  }
  
  @media (max-width: 900px) {
    .di-config-grid {
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .di-config-grid > div:first-child {
      grid-column: 1 / -1;
    }
  }
  
  @media (max-width: 600px) {
    .di-config-grid {
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .di-config-grid > div:first-child {
      grid-column: auto;
    }
  }

  
  /* Responsywno≈õƒá - pola w kolumnie na ma≈Çych ekranach */
  @media (max-width: 768px) {
    .grid[style*="grid-template-columns: 1fr 1fr 1fr"] {
      grid-template-columns: 1fr !important;
    }
  }
</style>

<div class="card">
  <h1 class="h1" data-i18n="page.diarization.title">Diarization</h1>

  <div class="topgrid">
    <div class="subcard">
      <div class="di-config-grid">
        <div>
          <div class="label">Tryb</div>
          <select id="di_mode">
            <option value="pyannote">pyannote (audio)</option>
            <option value="text">diaryzacja tekstu (prosta)</option>
          </select>
        </div>
        <div id="di_lang_block">
          <div class="label">Jƒôzyk</div>
          <select id="di_lang">
            <option value="auto">auto</option>
            <option value="pl">pl</option>
            <option value="en">en</option>
            <option value="de">de</option>
            <option value="fr">fr</option>
            <option value="es">es</option>
            <option value="uk">uk</option>
            <option value="ru">ru</option>
          </select>
        </div>
        <div id="di_model_block">
          <div class="label">Model Whisper</div>
          <select id="di_model">
            {% for m in whisper_models %}
            <option value="{{m}}" {% if m==default_whisper_model %}selected{% endif %}>{{m}}</option>
            {% endfor %}
          </select>
        </div>
      </div>
      <div class="small" style="margin-top: 6px">Tryb <b>pyannote</b> wymaga tokena HF (w Ustawieniach).</div>

      <div class="hr"></div>

      <div id="di_text_block" style="display:none">
        <div class="label">Tekst wej≈õciowy</div>
        <textarea id="di_text_in" style="min-height:140px" placeholder="Wklej tekst do prostej diaryzacji‚Ä¶"></textarea>

        <div class="hr"></div>

        <div class="grid" style="grid-template-columns: 1fr 1fr">
          <div>
            <div class="label">Liczba m√≥wc√≥w</div>
            <input class="input" id="di_speakers" type="number" min="1" max="20" value="2"/>
          </div>
          <div>
            <div class="label">Metoda</div>
            <select id="di_method">
              <option value="alternate">naprzemiennie</option>
              <option value="block">blokami</option>
              <option value="lines">po liniach</option>
              <option value="sentences">po zdaniach</option>
              <option value="sentences+merge">zdania + ≈ÇƒÖczenie</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="label">Mapowanie m√≥wc√≥w (JSON)</div>
        <textarea id="di_map" style="min-height:90px" placeholder='np. {"SPK1":"Jan","SPK2":"Anna"}'></textarea>
        <div class="small">Opcjonalnie: podmie≈Ñ etykiety <code>SPK1</code>, <code>SPK2</code> itd. na imiona.</div>
      </div>

      <div class="hr"></div>

      <div class="label">
        Nazwy m√≥wc√≥w
        <span style="font-weight:normal;font-size:12px;color:#888;margin-left:8px;">
          (wykryte automatycznie)
        </span>
      </div>
      
      <div id="speaker_mapping_ui" class="speaker-mapping-container">
        <div class="mapping-empty">
          Wykonaj diaryzacjƒô aby wykryƒá m√≥wc√≥w üé§
        </div>
      </div>
      
      <div class="advanced-toggle" id="toggle_json_editor">
        ‚öôÔ∏è Zaawansowane: edycja JSON
      </div>
      
      <div id="json_editor_container" class="json-editor">
        <textarea id="di_speaker_map" style="min-height:120px;font-family:monospace;font-size:12px;" placeholder='{"SPEAKER_00":"Jan","SPEAKER_01":"Anna"}'></textarea>
        <div class="small" style="margin-top:6px">
          ‚ö†Ô∏è Uwaga: rƒôczna edycja JSON - b≈Çƒôdy sk≈Çadniowe spowodujƒÖ problemy.
          <button class="btn secondary" style="margin-left:10px;padding:4px 10px;font-size:12px;" id="sync_from_json">
            Za≈Çaduj z JSON
          </button>
        </div>
      </div>

      <div class="row" style="margin-top:14px; flex-wrap:wrap; gap:10px">
        <button class="btn" id="di_apply_map" title="Zamie≈Ñ wszystkie wystƒÖpienia SPEAKER_XX na wpisane imiona">
          ‚ú® Wprowad≈∫ zmiany
        </button>
        <button class="btn secondary" id="di_export_toggle" title="Eksportuj raport diaryzacji">
          üì• Eksportuj raport
        </button>
      </div>
      
      <!-- Panel eksportu raport√≥w (ukryty domy≈õlnie) -->
      <div id="di_export_panel" style="display:none; margin-top:14px; background:#f0f4fa; border:1px solid #ddd; border-radius:8px; padding:16px;">
        <div class="label">Wybierz formaty raport√≥w (mo≈ºesz zaznaczyƒá kilka)</div>
        <div class="row" style="gap:12px; margin-bottom:12px; flex-wrap:wrap;">
          <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
            <input type="checkbox" id="di_format_txt"> üìÑ TXT
          </label>
          <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
            <input type="checkbox" id="di_format_html" checked> üìä HTML
          </label>
          <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
            <input type="checkbox" id="di_format_pdf"> üìï PDF
          </label>
        </div>
        
        <div class="label">Opcje eksportu</div>
        <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:14px;">
          <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
            <input type="checkbox" id="di_report_logs"> Do≈ÇƒÖcz logi systemowe
          </label>
          <label style="display:flex; align-items:center; gap:8px; cursor:pointer;">
            <input type="checkbox" id="di_report_timestamps" checked> Uwzglƒôdnij timestampy
          </label>
        </div>
        
        <div class="row" style="gap:10px;">
          <button class="btn" id="di_generate_report">
            üöÄ Generuj raporty
          </button>
          <button class="btn secondary" id="di_export_cancel">
            ‚úï Anuluj
          </button>
        </div>
        
        <div class="small" style="margin-top:10px; opacity:0.8;">
          üí° Raporty zostanƒÖ zapisane w folderze projektu i bƒôdƒÖ dostƒôpne do pobrania.
        </div>
      </div>
      
      <div class="small" style="margin-top:10px">
        <strong>Jak u≈ºyƒá:</strong> Wpisz imiona w pola obok etykiet (zapisujƒÖ siƒô automatycznie) ‚Üí Kliknij <strong>"Wprowad≈∫ zmiany"</strong> aby zamieniƒá etykiety SPEAKER_XX na imiona w tek≈õcie
      </div>
    </div>

    <div class="subcard">
      <div class="row" style="flex-wrap:wrap">
        <button class="btn" id="di_btn" data-i18n="btn.diarize">Diaryzuj</button>
        <a class="btn secondary" id="di_download" href="#" style="display:none">Pobierz TXT</a>
      </div>

      <div class="small" style="margin-top:10px">
        Status: <b id="di_status">‚Äî</b> ‚Ä¢ Postƒôp: <span id="di_pct">0%</span>
      </div>
      <div class="progress" style="margin-top:10px"><div id="di_bar"></div></div>
      <div class="small" style="margin-top:10px">Logi sƒÖ dostƒôpne w zak≈Çadce <b>Logi</b>.</div>
    </div>
  </div>

  <div class="hr"></div>

  <div class="label">Wynik diaryzacji</div>
  <div class="small" style="margin-bottom:8px">Najed≈∫ myszkƒÖ na blok aby ods≈Çuchaƒá fragment ‚Ä¢ Prawy przycisk myszy na bloku: edycja.</div>
  <div id="di_blocks" class="blocklist" style="display:none"></div>
  <textarea id="di_out" class="bigarea" placeholder="Tutaj pojawi siƒô wynik‚Ä¶"></textarea>
  <div class="small" style="margin-top:6px">
    ‚ú® <strong>Wszystkie zmiany zapisujƒÖ siƒô automatycznie</strong> - edytuj bloki, zmieniaj nazwy m√≥wc√≥w, wszystko jest synchronizowane z projektem w czasie rzeczywistym.
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
"use strict";

// ========== Diarization State ==========
const DI = {
  segments: [],
  audio: null,
  audioUrl: "",
  activeIdx: -1,
  endWatch: null,
  speakerColors: {}
};

// ========== Auto-save ==========
let autoSaveTimeout = null;
let hasUnsavedChanges = false;

// ========== Helper Functions ==========

// Parse diarization line: [12.34-15.67] SPEAKER_00: text
function parseDiarizedLine(line){
  const m = line.match(/^\s*\[(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\]\s*([A-Za-z0-9_\-]+)\s*:\s*(.*)$/);
  if(!m) return null;
  return {
    start: parseFloat(m[1]),
    end: parseFloat(m[2]),
    speaker: m[3].trim(),
    text: m[4].trim()
  };
}

// Parse entire diarized text into segments
function parseDiarizedText(text){
  const segments = [];
  const lines = String(text || "").split(/\r?\n/);
  for(const line of lines){
    const seg = parseDiarizedLine(line);
    if(seg) segments.push(seg);
  }
  return segments;
}

// Format timestamp for display
function formatTime(sec){
  const s = Math.max(0, Number(sec)||0);
  const mm = Math.floor(s / 60);
  const ss = (s % 60).toFixed(3);
  return mm + ":" + String(ss).padStart(6,'0');
}

// Get audio URL
function diAudioUrl(){
  const pid = AISTATE.projectId || "";
  const f = AISTATE.audioFile || "";
  if(!pid || !f) return "";
  return "/api/projects/" + pid + "/download/" + encodeURIComponent(f);
}

// Stop playback
function diStopPlayback(){
  if(DI.endWatch){ clearInterval(DI.endWatch); DI.endWatch=null; }
  if(DI.audio){ try{ DI.audio.pause(); }catch(e){} }
  if(DI.activeIdx>=0){
    const old = document.querySelector(".seg[data-idx='" + DI.activeIdx + "']");
    if(old) old.classList.remove("seg-active");
  }
  DI.activeIdx = -1;
}

// Play segment
function diPlaySegment(idx, fromStart){
  if(fromStart === undefined) fromStart = true;
  if(!DI.audio || !DI.audioUrl) return;
  const seg = DI.segments[idx];
  if(!seg) return;

  diStopPlayback();
  DI.activeIdx = idx;
  const elSeg = document.querySelector(".seg[data-idx='" + idx + "']");
  if(elSeg) elSeg.classList.add("seg-active");

  const endT = Math.max(0, Number(seg.end)||0);
  const startT = Math.max(0, Number(seg.start)||0);
  if(fromStart || DI.audio.currentTime < startT || DI.audio.currentTime > endT){
    DI.audio.currentTime = startT;
  }
  DI.audio.play().catch(function(){});

  DI.endWatch = setInterval(function(){
    if(!DI.audio) return;
    if(DI.audio.currentTime >= (endT - 0.02)){
      try{ DI.audio.pause(); }catch(e){}
      clearInterval(DI.endWatch);
      DI.endWatch = null;
    }
  }, 50);
}

// Assign color to speaker
function getSpeakerColor(speaker){
  if(!DI.speakerColors[speaker]){
    const idx = Object.keys(DI.speakerColors).length % 10;
    DI.speakerColors[speaker] = "speaker-" + idx;
  }
  return DI.speakerColors[speaker];
}

// Build raw text from segments
function diBuildRawText(){
  if(!DI.segments || !DI.segments.length){
    return document.getElementById("di_out").value || "";
  }
  return DI.segments.map(function(s){
    return "[" + s.start.toFixed(2) + "-" + s.end.toFixed(2) + "] " + s.speaker + ": " + s.text;
  }).join("\n");
}

// Update textarea with current segments
function diSetRawTextarea(){
  document.getElementById("di_out").value = diBuildRawText();
}

// Render blocks
function diRender(){
  const blocks = document.getElementById("di_blocks");
  const ta = document.getElementById("di_out");
  
  if(!DI.segments || DI.segments.length === 0){
    blocks.style.display = "none";
    ta.style.display = "block";
    return;
  }
  
  blocks.style.display = "flex";
  ta.style.display = "none";
  blocks.innerHTML = "";

  DI.audioUrl = diAudioUrl();
  if(DI.audioUrl){
    if(!DI.audio){
      DI.audio = new Audio();
      DI.audio.preload = "metadata";
    }
    DI.audio.src = DI.audioUrl;
  }

  DI.segments.forEach(function(seg, idx){
    const d = document.createElement("div");
    d.className = "seg " + getSpeakerColor(seg.speaker);
    d.dataset.idx = String(idx);
    
    d.innerHTML='<div class="seg-time">'+formatTime(seg.start)+' ‚Üí '+formatTime(seg.end)+' <strong>'+seg.speaker+'</strong></div>' +
                  '<div class="seg-text"></div>';
    d.querySelector(".seg-text").textContent = seg.text || "";

    d.addEventListener("mouseenter", function(){ diPlaySegment(idx, true); });
    d.addEventListener("mouseleave", function(){ diStopPlayback(); });
    
    blocks.appendChild(d);
  });
  
  diSetRawTextarea();
}

// Extract speaker labels from diarization output
function extractSpeakerLabels(text){
  const labels = new Set();
  String(text || "").split(/\r?\n/).forEach(function(line){
    const cleaned = line.replace(/^\s*\[[\d\.\-]+\]\s*/, '');
    const m = cleaned.match(/^\s*([A-Za-z0-9_\-]{1,40})\s*:/);
    if(m && m[1]) {
      labels.add(m[1].trim());
    }
  });
  
  const result = Array.from(labels).sort();
  console.log('üîç Znalezione etykiety m√≥wc√≥w:', result);
  return result;
}

// Count occurrences of a speaker label in text
function countSpeakerOccurrences(text, label){
  const escaped = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const matches = text.match(new RegExp(escaped, 'g'));
  return matches ? matches.length : 0;
}

// Show temporary toast notification
function showToast(message, duration){
  if(duration === undefined) duration = 2000;
  let toast = document.getElementById('speaker_toast');
  if(!toast){
    toast = document.createElement('div');
    toast.id = 'speaker_toast';
    document.body.appendChild(toast);
  }
  
  toast.textContent = message;
  toast.style.opacity = '1';
  
  clearTimeout(toast._timer);
  toast._timer = setTimeout(function(){
    toast.style.opacity = '0';
  }, duration);
}

// Render speaker mapping UI
function renderSpeakerMappingUI(labels, outputText){
  const container = document.getElementById('speaker_mapping_ui');
  if(!container) return;
  
  if(!labels || labels.length === 0){
    container.innerHTML = '<div class="mapping-empty">Wykonaj diaryzacjƒô aby wykryƒá m√≥wc√≥w üé§</div>';
    return;
  }
  
  let currentMapping = {};
  try{
    const raw = document.getElementById('di_speaker_map').value || '';
    if(raw.trim()) currentMapping = JSON.parse(raw);
  }catch(e){}
  
  container.innerHTML = '';
  
  labels.forEach(function(label){
    const row = document.createElement('div');
    row.className = 'speaker-mapping-row';
    
    const labelEl = document.createElement('div');
    labelEl.className = 'speaker-label';
    labelEl.textContent = label;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'speaker-input';
    input.value = currentMapping[label] || label;
    input.placeholder = 'Wpisz imiƒô dla ' + label;
    input.dataset.speaker = label;
    
    input.addEventListener('input', function(){
      syncToJSON();
      scheduleAutoSave(); // Auto-save mapowania i wyniku
    });
    
    const countEl = document.createElement('div');
    countEl.className = 'speaker-count';
    if(outputText){
      const count = countSpeakerOccurrences(outputText, label);
      countEl.textContent = count > 0 ? (count + '√ó') : '';
    }
    
    row.appendChild(labelEl);
    row.appendChild(input);
    row.appendChild(countEl);
    container.appendChild(row);
  });
  
  console.log('‚úÖ Wygenerowano UI dla ' + labels.length + ' m√≥wc√≥w');
  showToast('üîÑ Zaktualizowano ' + labels.length + ' m√≥wc√≥w');
}

// Sync UI inputs to hidden JSON textarea
function syncToJSON(){
  const inputs = document.querySelectorAll('.speaker-input');
  const mapping = {};
  
  inputs.forEach(function(input){
    const label = input.dataset.speaker;
    const value = input.value.trim() || label;
    mapping[label] = value;
  });
  
  const jsonTextarea = document.getElementById('di_speaker_map');
  if(jsonTextarea){
    jsonTextarea.value = JSON.stringify(mapping, null, 2);
  }
  
  console.log('üîÑ Zsynchronizowano mapowanie do JSON:', mapping);
}

// Sync JSON textarea to UI inputs
function syncFromJSON(){
  try{
    const raw = document.getElementById('di_speaker_map').value || '';
    if(!raw.trim()) return;
    
    const mapping = JSON.parse(raw);
    const inputs = document.querySelectorAll('.speaker-input');
    
    inputs.forEach(function(input){
      const label = input.dataset.speaker;
      if(mapping[label] !== undefined){
        input.value = mapping[label];
      }
    });
    
    console.log('‚úÖ Za≈Çadowano mapowanie z JSON do UI');
    alert('‚úÖ Mapowanie za≈Çadowane z JSON');
  }catch(e){
    alert('‚ùå B≈ÇƒÖd parsowania JSON: ' + e.message);
  }
}

// Merge speaker map (preserves manual names)
function mergeSpeakerMap(labels){
  const ta = document.getElementById("di_speaker_map");
  if(!ta) return;

  let current = {};
  const raw = (ta.value || "").trim();
  
  if(raw){
    try{
      const j = JSON.parse(raw);
      if(j && typeof j === "object" && !Array.isArray(j)){
        current = j;
      }
    }catch(e){
      console.warn('‚ö†Ô∏è Niepoprawny JSON w mapowaniu, tworzƒô nowy:', e.message);
      current = {};
    }
  }

  let changed = false;
  for(let i=0; i<labels.length; i++){
    const lab = labels[i];
    if(!(lab in current)){
      current[lab] = lab;
      changed = true;
      console.log('‚ûï Dodano nowƒÖ etykietƒô do mapowania:', lab);
    } else {
      console.log('‚úì Zachowano istniejƒÖcƒÖ nazwƒô dla:', lab, '‚Üí', current[lab]);
    }
  }

  if(changed || !raw){
    ta.value = JSON.stringify(current, null, 2);
    console.log('‚úÖ Zaktualizowano mapowanie m√≥wc√≥w:', current);
  }
  
  const outText = document.getElementById('di_out') ? (document.getElementById('di_out').value || '') : '';
  renderSpeakerMappingUI(labels, outText);
}

function setDownloadLink(projectId){
  const dl = document.getElementById("di_download");
  if(!dl) return;
  dl.href = "/api/projects/" + projectId + "/download/diarized.txt";
  dl.style.display = "inline-flex";
}

let DI_HAS_AUDIO = false;

async function updateAudioState(){
  await refreshCurrentProjectInfo();
  DI_HAS_AUDIO = Boolean(AISTATE.projectId && AISTATE.audioFile);
  const btn = document.getElementById("di_btn");
  if(btn){
    const modeEl = document.getElementById("di_mode");
    const mode = modeEl ? (modeEl.value || "pyannote") : "pyannote";
    const needAudio = (mode === "pyannote");
    btn.disabled = needAudio && !DI_HAS_AUDIO;
  }
}

async function loadProjectJson(projectId){
  try{
    const raw = await api("/api/projects/" + projectId + "/download/project.json");
    return JSON.parse(String(raw || "{}"));
  }catch(e){
    return {};
  }
}

const LS = {
  get: function(key){ try{ return localStorage.getItem(key); }catch(e){ return null; } },
  set: function(key,val){ try{ localStorage.setItem(key, val); }catch(e){} }
};

function draftKeys(projectId){
  return {
    diarized: "aistateweb:draft:diarized:" + projectId,
    speakerMap: "aistateweb:draft:speaker_map:" + projectId
  };
}

function setupDraftAutosave(projectId){
  const keys = draftKeys(projectId);

  const out = document.getElementById("di_out");
  if(out){
    let refreshTimeout = null;
    out.addEventListener("input", function(){
      // Zapisz do localStorage (draft)
      LS.set(keys.diarized, out.value || "");
      
      // Auto-refresh mapowania (debounce 500ms - szybciej ni≈º auto-save)
      clearTimeout(refreshTimeout);
      refreshTimeout = setTimeout(function(){
        const text = out.value || "";
        if(text.trim()){
          // Automatycznie wykryj m√≥wc√≥w i od≈õwie≈º UI
          const labels = extractSpeakerLabels(text);
          if(labels.length){
            mergeSpeakerMap(labels);
            console.log('üîÑ Auto-refreshed speaker mapping from textarea edit');
          }
          
          // Od≈õwie≈º segments i bloki
          const segments = parseDiarizedText(text);
          if(segments.length){
            DI.segments = segments;
            diRender();
            console.log('üîÑ Auto-refreshed ' + segments.length + ' blocks from textarea edit');
          }
        }
      }, 500);
      
      // Auto-save wszystkiego (debounce 1s)
      scheduleAutoSave();
    });
  }

  const sm = document.getElementById("di_speaker_map");
  if(sm){
    sm.addEventListener("input", function(){
      LS.set(keys.speakerMap, sm.value || "");
      scheduleAutoSave(); // Auto-save mapowania
    });
  }
}

async function restoreOutputs(projectId){
  const keys = draftKeys(projectId);

  const out = document.getElementById("di_out");
  const sm = document.getElementById("di_speaker_map");

  const draftOut = LS.get(keys.diarized);
  if(out && !out.value.trim() && draftOut && String(draftOut).trim()){
    out.value = String(draftOut);
  }

  const draftMap = LS.get(keys.speakerMap);
  if(sm && !sm.value.trim() && draftMap && String(draftMap).trim()){
    sm.value = String(draftMap);
  }

  const meta = await loadProjectJson(projectId);

  if(sm && !sm.value.trim() && meta && typeof meta === "object" && meta.speaker_map){
    try{
      sm.value = JSON.stringify(meta.speaker_map, null, 2);
    }catch(e){}
  }

  if(out && !out.value.trim()){
    try{
      const txt = await api("/api/projects/" + projectId + "/download/diarized.txt");
      if(txt && String(txt).trim()){
        out.value = String(txt);
        setDownloadLink(projectId);
      }
    }catch(e){}
  }

  if(out && out.value.trim()){
    console.log('üîÑ Od≈õwie≈ºam mapowanie z za≈Çadowanego wyniku...');
    
    const segments = parseDiarizedText(out.value);
    if(segments.length){
      DI.segments = segments;
      diRender();
      console.log('‚úÖ Wyrenderowano ' + segments.length + ' blok√≥w z zapisanego wyniku');
    }
    
    const labels = extractSpeakerLabels(out.value);
    if(labels.length) {
      mergeSpeakerMap(labels);
    }
  }
}

// ========== Auto-save Functions ==========

async function autoSaveAll(){
  const pid = AISTATE.projectId;
  if(!pid) return;
  
  try{
    // 1. Zapisz wynik diaryzacji
    const text = diBuildRawText();
    if(text.trim()){
      await api("/api/projects/" + pid + "/save_diarized", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify({ text: text })
      });
      console.log('‚úÖ Auto-saved diarization to project');
      
      const keys = draftKeys(pid);
      LS.set(keys.diarized, text);
    }
    
    // 2. Zapisz mapowanie m√≥wc√≥w
    const raw = document.getElementById("di_speaker_map").value || "";
    if(raw.trim()){
      try{
        const mapping = JSON.parse(raw);
        await api("/api/projects/" + pid + "/speaker_map", {
          method:"POST",
          headers:{ "content-type":"application/json" },
          body: JSON.stringify({ mapping: mapping })
        });
        console.log('‚úÖ Auto-saved speaker mapping to project');
        
        const keys = draftKeys(pid);
        LS.set(keys.speakerMap, raw);
      }catch(e){
        console.warn('‚ö†Ô∏è Invalid speaker mapping JSON, skipping mapping save');
      }
    }
    
    markSaved();
  }catch(e){
    console.warn('‚ö†Ô∏è Auto-save failed:', e);
  }
}

function scheduleAutoSave(){
  markUnsaved();
  clearTimeout(autoSaveTimeout);
  autoSaveTimeout = setTimeout(autoSaveAll, 1000); // 1 sekunda debounce
}

function markUnsaved(){
  hasUnsavedChanges = true;
  // Opcjonalnie mo≈ºna dodaƒá wizualny wska≈∫nik w przysz≈Ço≈õci
}

function markSaved(){
  hasUnsavedChanges = false;
  // Opcjonalnie mo≈ºna dodaƒá wizualny wska≈∫nik w przysz≈Ço≈õci
}

function onDoneDiarize(j){
  console.log('‚úÖ Diaryzacja zako≈Ñczona, przetwarzam wynik...');
  
  if(j.result && j.result.text){
    const out = j.result.text;
    const outEl = document.getElementById("di_out");
    if(outEl) {
      outEl.value = out;
      console.log('üìù Wynik diaryzacji zapisany do pola tekstowego');
    }

    const segments = parseDiarizedText(out);
    if(segments.length){
      DI.segments = segments;
      diRender();
      console.log('‚úÖ Wyrenderowano ' + segments.length + ' blok√≥w');
    }

    console.log('üîç Wykrywam m√≥wc√≥w z wyniku...');
    const labels = extractSpeakerLabels(out);
    
    if(labels.length) {
      console.log('‚úÖ Znaleziono ' + labels.length + ' m√≥wc√≥w:', labels);
      mergeSpeakerMap(labels);
    } else {
      console.warn('‚ö†Ô∏è Nie znaleziono ≈ºadnych etykiet m√≥wc√≥w');
    }

    if(AISTATE.projectId){
      const keys = draftKeys(AISTATE.projectId);
      LS.set(keys.diarized, out);
    }

    if(j.project_id){
      setDownloadLink(j.project_id);
    }
  }
}

function toggleMode(){
  const mode = document.getElementById("di_mode").value;
  const isPyannote = (mode === "pyannote");
  
  document.getElementById("di_lang_block").style.display = isPyannote ? "block" : "none";
  document.getElementById("di_model_block").style.display = isPyannote ? "block" : "none";
  document.getElementById("di_text_block").style.display = isPyannote ? "none" : "block";
  
  updateAudioState();
}

// ========== Export Report Functions ==========

function toggleExportPanel(){
  const panel = document.getElementById("di_export_panel");
  if(!panel) return;
  
  if(panel.style.display === "none"){
    panel.style.display = "block";
  } else {
    panel.style.display = "none";
  }
}

function closeExportPanel(){
  const panel = document.getElementById("di_export_panel");
  if(panel) panel.style.display = "none";
}

async function generateDiarReport(){
  const pid = AISTATE.projectId;
  if(!pid){
    alert("Brak aktywnego projektu. Najpierw utw√≥rz projekt w zak≈Çadce 'Nowy projekt'.");
    return;
  }
  
  const outEl = document.getElementById("di_out");
  if(!outEl || !outEl.value.trim()){
    alert("Brak wyniku diaryzacji do wyeksportowania. Najpierw wykonaj diaryzacjƒô.");
    return;
  }
  
  // Zbierz zaznaczone formaty
  const formats = [];
  if(document.getElementById("di_format_txt").checked) formats.push("txt");
  if(document.getElementById("di_format_html").checked) formats.push("html");
  if(document.getElementById("di_format_pdf").checked) formats.push("pdf");
  
  if(formats.length === 0){
    alert("Wybierz przynajmniej jeden format raportu (TXT, HTML lub PDF).");
    return;
  }
  
  const includeLogs = document.getElementById("di_report_logs").checked ? 1 : 0;
  
  try{
    const btn = document.getElementById("di_generate_report");
    const originalText = btn.textContent;
    btn.textContent = "‚è≥ Generujƒô...";
    btn.disabled = true;
    
    const results = [];
    
    // Generuj ka≈ºdy zaznaczony format
    for(const format of formats){
      const url = `/api/projects/${pid}/report?format=${format}&include_logs=${includeLogs}`;
      const response = await fetch(url);
      
      if(!response.ok){
        const errorText = await response.text();
        throw new Error(`${format.toUpperCase()}: ${errorText || 'HTTP ' + response.status}`);
      }
      
      const blob = await response.blob();
      const downloadUrl = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = `diarization_report_${new Date().getTime()}.${format}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(downloadUrl);
      
      results.push(format.toUpperCase());
      
      // Ma≈Çe op√≥≈∫nienie miƒôdzy pobieraniami (dla stabilno≈õci przeglƒÖdarki)
      if(formats.length > 1 && format !== formats[formats.length - 1]){
        await new Promise(resolve => setTimeout(resolve, 300));
      }
    }
    
    btn.textContent = originalText;
    btn.disabled = false;
    
    closeExportPanel();
    
    const message = results.length === 1 
      ? `‚úÖ Raport ${results[0]} wygenerowany`
      : `‚úÖ Raporty wygenerowane: ${results.join(', ')}`;
    
    showToast(message + ' i zapisane w projekcie', 3000);
    
  }catch(e){
    const btn = document.getElementById("di_generate_report");
    btn.textContent = "üöÄ Generuj raporty";
    btn.disabled = false;
    
    alert(`‚ùå B≈ÇƒÖd generowania raportu: ${e.message}`);
    console.error('Report generation error:', e);
  }
}


// ========== Event Listeners ==========

document.getElementById("di_mode").addEventListener("change", toggleMode);
toggleMode();

document.getElementById("di_btn").addEventListener("click", async function(){
  const mode = document.getElementById("di_mode").value;
  const fd = new FormData();

  if(mode === "pyannote"){
    await updateAudioState();
    if(!DI_HAS_AUDIO){
      alert("Brak pliku audio w projekcie. Utw√≥rz projekt w zak≈Çadce: Nowy projekt.");
      window.location.href = "/new-project";
      return;
    }
    fd.append("lang", document.getElementById("di_lang").value);
    fd.append("model", document.getElementById("di_model").value);
    await startTask("di", "/api/diarize_voice", fd, onDoneDiarize);
  } else {
    const text = document.getElementById("di_text_in").value || "";
    if(!text.trim()){ alert("Wklej tekst wej≈õciowy."); return; }
    fd.append("text", text);
    fd.append("speakers", document.getElementById("di_speakers").value || "2");
    fd.append("method", document.getElementById("di_method").value || "alternate");
    fd.append("mapping_json", document.getElementById("di_map").value || "");
    await startTask("di", "/api/diarize_text", fd, onDoneDiarize);
  }
});

document.getElementById("di_apply_map").addEventListener("click", function(){
  syncToJSON();
  
  let mapping = {};
  const raw = document.getElementById("di_speaker_map").value || "";
  if(raw.trim()){
    try{ mapping = JSON.parse(raw); }catch(e){ alert("Niepoprawny JSON mapowania."); return; }
  }
  
  const outEl = document.getElementById("di_out");
  let out = outEl.value || "";
  
  let totalReplacements = 0;
  const details = [];
  
  for(const k in mapping){
    if(!mapping.hasOwnProperty(k)) continue;
    const v = mapping[k];
    if(k === v) continue;
    const count = (out.match(new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
    if(count > 0){
      out = out.split(k).join(v);
      totalReplacements += count;
      details.push(k + ' ‚Üí ' + v + ' (' + count + '√ó)');
    }
  }
  
  outEl.value = out;
  
  if(totalReplacements > 0){
    console.log('‚úÖ Zastosowano mapowanie m√≥wc√≥w:', details.join(', '));
    
    const segments = parseDiarizedText(out);
    if(segments.length){
      DI.segments = segments;
      DI.speakerColors = {};
      diRender();
    }
    
    const labels = extractSpeakerLabels(out);
    renderSpeakerMappingUI(labels, out);
    
    // ‚ú® Auto-save po zastosowaniu mapowania
    scheduleAutoSave();
    
    alert("‚úÖ Wprowadzono zmiany:\n\n" + details.join('\n') + "\n\nRazem: " + totalReplacements + " zamian");
  } else {
    alert('‚ÑπÔ∏è Nie znaleziono ≈ºadnych wystƒÖpie≈Ñ do zamiany. Sprawd≈∫ czy etykiety w mapowaniu pasujƒÖ do tych w wyniku.');
  }
});

document.getElementById("toggle_json_editor").addEventListener("click", function(){
  const container = document.getElementById("json_editor_container");
  container.classList.toggle("show");
  
  const toggle = document.getElementById("toggle_json_editor");
  if(container.classList.contains("show")){
    toggle.textContent = "‚öôÔ∏è Zaawansowane: ukryj JSON";
  } else {
    toggle.textContent = "‚öôÔ∏è Zaawansowane: edycja JSON";
  }
});

document.getElementById("sync_from_json").addEventListener("click", syncFromJSON);

// Export report listeners
document.getElementById("di_export_toggle").addEventListener("click", toggleExportPanel);
document.getElementById("di_export_cancel").addEventListener("click", closeExportPanel);
document.getElementById("di_generate_report").addEventListener("click", generateDiarReport);


document.addEventListener('aistate:output-updated', function(e){
  console.log('üîî Received output-updated event:', e.detail);
  
  if(e.detail && e.detail.textareaId === 'di_out'){
    const outEl = document.getElementById("di_out");
    if(outEl && outEl.value.trim()){
      console.log('üîÑ Auto-refreshing speaker mapping and blocks from updated output...');
      
      const segments = parseDiarizedText(outEl.value);
      if(segments.length){
        DI.segments = segments;
        diRender();
        console.log('‚úÖ Re-rendered ' + segments.length + ' blocks');
      }
      
      const labels = extractSpeakerLabels(outEl.value);
      if(labels.length){
        mergeSpeakerMap(labels);
        showToast('‚úÖ Wykryto ' + labels.length + ' m√≥wc√≥w');
        console.log('‚úÖ Auto-refresh complete: ' + labels.length + ' speakers found:', labels);
      } else {
        console.warn('‚ö†Ô∏è No speaker labels found in output');
      }
      
      // ‚ú® Auto-save po aktualizacji z edytora modalnego
      scheduleAutoSave();
    }
  }
});

// Export global helpers for app.js integration
window.DI = DI;
window.diRender = diRender;
window.diBuildRawText = diBuildRawText;
window.parseDiarizedText = parseDiarizedText;
window.diStopPlayback = diStopPlayback;

(async function(){
  await updateAudioState();
  if(AISTATE.projectId){
    setupDraftAutosave(AISTATE.projectId);
    await restoreOutputs(AISTATE.projectId);
  }
  await resumeTask("di", onDoneDiarize);
})();
</script>
{% endblock %}
