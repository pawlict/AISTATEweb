{% extends "base.html" %}
{% block content %}
<div class="card">
  <h1 class="h1" data-i18n="page.diarization.title">Diarization</h1>

  <div class="topgrid">
    <div class="subcard">
      <div class="label">Tryb</div>
      <select id="di_mode">
        <option value="pyannote">pyannote (audio)</option>
        <option value="text">diaryzacja tekstu (prosta)</option>
      </select>
      <div class="small">Tryb <b>pyannote</b> wymaga tokena HF (w Ustawieniach).</div>

      <div class="hr"></div>

      <div id="di_pyannote_block">
        <div class="grid" style="grid-template-columns: 1fr 1fr">
          <div>
            <div class="label">Język</div>
            <select id="di_lang">
              <option value="auto">auto</option>
              <option value="pl">pl</option>
              <option value="en">en</option>
              <option value="de">de</option>
              <option value="fr">fr</option>
              <option value="es">es</option>
              <option value="uk">uk</option>
              <option value="ru">ru</option>
            </select>
          </div>
          <div>
            <div class="label">Model Whisper (do segmentów)</div>
            <select id="di_model">
              {% for m in whisper_models %}
              <option value="{{m}}" {% if m==default_whisper_model %}selected{% endif %}>{{m}}</option>
              {% endfor %}
            </select>
          </div>
        </div>

        <div class="hr"></div>
      </div>

      <div id="di_text_block" style="display:none">
        <div class="label">Tekst wejściowy</div>
        <textarea id="di_text_in" style="min-height:140px" placeholder="Wklej tekst do prostej diaryzacji…"></textarea>

        <div class="hr"></div>

        <div class="grid" style="grid-template-columns: 1fr 1fr">
          <div>
            <div class="label">Liczba mówców</div>
            <input class="input" id="di_speakers" type="number" min="1" max="20" value="2"/>
          </div>
          <div>
            <div class="label">Metoda</div>
            <select id="di_method">
              <option value="alternate">naprzemiennie</option>
              <option value="block">blokami</option>
              <option value="lines">po liniach</option>
              <option value="sentences">po zdaniach</option>
              <option value="sentences+merge">zdania + łączenie</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="label">Mapowanie mówców (JSON)</div>
        <textarea id="di_map" style="min-height:90px" placeholder='np. {"SPK1":"Jan","SPK2":"Anna"}'></textarea>
        <div class="small">Opcjonalnie: podmień etykiety <code>SPK1</code>, <code>SPK2</code> itd. na imiona.</div>
      </div>

      <div class="hr"></div>

      <div class="row" style="flex-wrap:wrap">
        <button class="btn" id="di_btn">Uruchom diaryzację</button>
        <a class="btn secondary" id="di_download" href="#" style="display:none">Pobierz TXT</a>
      </div>

      <div class="small" style="margin-top:10px">
        Status: <b id="di_status">—</b> • Postęp: <span id="di_pct">0%</span>
      </div>
      <div class="progress" style="margin-top:10px"><div id="di_bar"></div></div>
      <div class="small" style="margin-top:10px">Logi są dostępne w zakładce <b>Logi</b>.</div>
    </div>

    <div class="subcard">
      <div class="label">Nazwy mówców (mapowanie JSON)</div>
      <textarea id="di_speaker_map" style="min-height:140px" placeholder='np. {"SPEAKER_00":"Jan","SPEAKER_01":"Anna"}'></textarea>
      <div class="row" style="margin-top:10px; flex-wrap:wrap">
        <button class="btn secondary" id="di_apply_map">Zastosuj w podglądzie</button>
        <button class="btn secondary" id="di_save_map">Zapisz mapowanie w projekcie</button>
      </div>
      <div class="small">Działa dla etykiet typu <code>SPEAKER_00</code> (pyannote) oraz <code>SPK1</code> (tekst).</div>
    </div>
  </div>

  <div class="hr"></div>

  <div class="label">Wynik diaryzacji</div>
  <div class="small" style="margin-bottom:8px">Najedź myszką na blok aby odsłuchać fragment • Prawy przycisk myszy na bloku: edycja (tylko dla trybu audio).</div>
  <div id="di_blocks" class="blocklist" style="display:none"></div>
  <textarea id="di_out" class="bigarea" placeholder="Tutaj pojawi się wynik…"></textarea>
  <div class="row" style="margin-top:10px; flex-wrap:wrap">
    <button class="btn secondary" id="di_save_txt">Zapisz wynik w projekcie</button>
  </div>
  <div class="small">Zapis tworzy plik w projekcie (np. <code>diarized.txt</code>).</div>

  <!-- Modal: segment editor -->
  <div id="di_modal" class="modal" style="display:none">
    <div class="modal-backdrop" id="di_modal_back"></div>
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="di_modal_title">
      <div class="modal-head">
        <div>
          <div class="modal-title" id="di_modal_title">Edycja bloku</div>
          <div class="small" id="di_modal_meta">—</div>
        </div>
        <button class="btn secondary" id="di_modal_close">Zamknij</button>
      </div>
      <div class="row" style="flex-wrap:wrap">
        <button class="btn" id="di_m_play">Play</button>
        <button class="btn secondary" id="di_m_pause">Pause</button>
        <button class="btn secondary" id="di_m_stop">Stop</button>
      </div>
      <div class="hr"></div>
      <div class="label">Tekst</div>
      <textarea id="di_m_text" style="min-height:160px"></textarea>
      <div class="row" style="margin-top:10px; flex-wrap:wrap">
        <button class="btn" id="di_m_save">Zapisz zmianę</button>
        <button class="btn secondary" id="di_m_cancel">Anuluj</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// -------- Segmented playback + editing (diarization) --------
const DI = {
  segments: [],
  audio: null,
  audioUrl: "",
  activeIdx: -1,
  endWatch: null,
  editIdx: -1,
};

function diAudioUrl(){
  const pid = AISTATE.projectId || "";
  const f = AISTATE.audioFile || "";
  if(!pid || !f) return "";
  return `/api/projects/${pid}/download/${encodeURIComponent(f)}`;
}

function diParseTs(s){
  const raw = String(s||"").trim();
  if(!raw) return null;
  if(/^[0-9]+(\.[0-9]+)?$/.test(raw)) return parseFloat(raw);
  const parts = raw.split(":").map(p=>p.trim());
  if(parts.length < 2 || parts.length > 3) return null;
  let h=0, m=0, sec=0;
  if(parts.length === 2){
    m = parseInt(parts[0]||"0",10);
    sec = parseFloat(parts[1]||"0");
  } else {
    h = parseInt(parts[0]||"0",10);
    m = parseInt(parts[1]||"0",10);
    sec = parseFloat(parts[2]||"0");
  }
  if([h,m,sec].some(x=>Number.isNaN(x))) return null;
  return h*3600 + m*60 + sec;
}

function diFmtTs(sec){
  // For diarization keep compact (2 decimals) when seconds are numeric.
  const s = Math.max(0, Number(sec)||0);
  return s.toFixed(2);
}

function diSegmentsFromText(text){
  const out=[];
  const lines = String(text||"").split(/\r?\n/);
  for(const ln of lines){
    const m = ln.match(/^\s*\[([^\]]+)\]\s*(.*)$/);
    if(!m) continue;
    const inside = m[1];
    const rest = (m[2]||"").trim();
    const parts = inside.split(/\s*[-–]\s*/);
    if(parts.length !== 2) continue;
    const s0 = diParseTs(parts[0]);
    const s1 = diParseTs(parts[1]);
    if(s0===null || s1===null) continue;
    let speaker = "";
    let txt = rest;
    const idxColon = rest.indexOf(":");
    if(idxColon > 0){
      speaker = rest.slice(0, idxColon).trim();
      txt = rest.slice(idxColon+1).trim();
    }
    out.push({start:s0, end:s1, speaker, text:txt});
  }
  return out;
}

function diBuildRawText(){
  if(!DI.segments || !DI.segments.length) return (document.getElementById("di_out").value||"");
  return DI.segments.map(s=>{
    const sp = (s.speaker||"").trim();
    const head = sp ? `${sp}: ` : "";
    return `[${diFmtTs(s.start)}-${diFmtTs(s.end)}] ${head}${(s.text||"").trim()}`.trim();
  }).join("\n");
}

function diSetRawTextarea(){
  document.getElementById("di_out").value = diBuildRawText();
}

function diStopPlayback(){
  if(DI.endWatch){ clearInterval(DI.endWatch); DI.endWatch=null; }
  if(DI.audio){ try{ DI.audio.pause(); }catch(e){} }
  if(DI.activeIdx>=0){
    const old = document.querySelector(`.seg[data-idx='${DI.activeIdx}']`);
    if(old) old.classList.remove("seg-active");
  }
  DI.activeIdx = -1;
}

function diPlaySegment(idx, fromStart=true){
  if(!DI.audio || !DI.audioUrl) return;
  const seg = DI.segments[idx];
  if(!seg) return;

  diStopPlayback();
  DI.activeIdx = idx;
  const elSeg = document.querySelector(`.seg[data-idx='${idx}']`);
  if(elSeg) elSeg.classList.add("seg-active");

  const endT = Math.max(0, Number(seg.end)||0);
  const startT = Math.max(0, Number(seg.start)||0);
  if(fromStart || DI.audio.currentTime < startT || DI.audio.currentTime > endT){
    DI.audio.currentTime = startT;
  }
  DI.audio.play().catch(()=>{});
  DI.endWatch = setInterval(()=>{
    if(!DI.audio) return;
    if(DI.audio.currentTime >= (endT - 0.02)){
      try{ DI.audio.pause(); }catch(e){}
      clearInterval(DI.endWatch);
      DI.endWatch = null;
    }
  }, 50);
}

function diOpenModal(idx){
  const seg = DI.segments[idx];
  if(!seg) return;
  DI.editIdx = idx;
  const sp = (seg.speaker||"").trim();
  document.getElementById("di_modal_meta").textContent = `${diFmtTs(seg.start)} → ${diFmtTs(seg.end)}${sp ? " • " + sp : ""}`;
  document.getElementById("di_m_text").value = seg.text || "";
  document.getElementById("di_modal").style.display = "flex";
}

function diCloseModal(){
  diStopPlayback();
  DI.editIdx = -1;
  document.getElementById("di_modal").style.display = "none";
}

function diRender(){
  const blocks = document.getElementById("di_blocks");
  const ta = document.getElementById("di_out");
  if(!DI.segments || DI.segments.length === 0){
    blocks.style.display = "none";
    ta.style.display = "block";
    return;
  }
  blocks.style.display = "block";
  ta.style.display = "none";
  blocks.innerHTML = "";

  DI.audioUrl = diAudioUrl();
  if(DI.audioUrl){
    if(!DI.audio){
      DI.audio = new Audio();
      DI.audio.preload = "metadata";
    }
    DI.audio.src = DI.audioUrl;
  }

  DI.segments.forEach((seg, idx)=>{
    const d = document.createElement("div");
    d.className = "seg";
    d.dataset.idx = String(idx);
    const sp = (seg.speaker||"").trim();
    d.innerHTML = `
      <div class="seg-time">${diFmtTs(seg.start)} → ${diFmtTs(seg.end)}</div>
      <div class="seg-text"><span class="seg-speaker"></span><span class="seg-body"></span></div>
    `;
    d.querySelector(".seg-speaker").textContent = sp ? (sp + ":") : "";
    d.querySelector(".seg-body").textContent = (sp ? " " : "") + (seg.text||"");

    // Hover playback only when audio exists (pyannote mode)
    if(DI.audioUrl){
      d.addEventListener("mouseenter", ()=> diPlaySegment(idx, true));
      d.addEventListener("mouseleave", ()=> diStopPlayback());
    }
    d.addEventListener("contextmenu", (ev)=>{
      ev.preventDefault();
      diOpenModal(idx);
    });
    blocks.appendChild(d);
  });
  diSetRawTextarea();
}

function onDoneDiarize(j){
  if(j.result && j.result.text){
    // Prefer structured segments if available
    const segs = (j.result.segments && Array.isArray(j.result.segments)) ? j.result.segments : [];
    if(segs.length){
      DI.segments = segs.map(s=>({
        start:Number(s.start)||0,
        end:Number(s.end)||0,
        speaker:String(s.speaker||"").trim(),
        text:String(s.text||"").trim(),
      }));
      diRender();
    } else {
      document.getElementById("di_out").value = j.result.text;
      const parsed = diSegmentsFromText(j.result.text);
      if(parsed.length){
        DI.segments = parsed;
        diRender();
      }
    }
    if(j.project_id){
      const dl = document.getElementById("di_download");
      dl.href = `/api/projects/${j.project_id}/download/diarized.txt`;
      dl.style.display = "inline-flex";
    }
  }
}

let DI_HAS_AUDIO = false;

function toggleMode(){
  const mode = document.getElementById("di_mode").value;
  document.getElementById("di_pyannote_block").style.display = (mode==="pyannote") ? "block" : "none";
  document.getElementById("di_text_block").style.display = (mode==="text") ? "block" : "none";
}
document.getElementById("di_mode").addEventListener("change", toggleMode);
toggleMode();

document.getElementById("di_btn").addEventListener("click", async ()=>{
  const mode = document.getElementById("di_mode").value;
  const fd = new FormData();

  if(mode === "pyannote"){
    if(!DI_HAS_AUDIO){
      alert("Brak pliku audio w projekcie. Utwórz projekt w zakładce: Nowy projekt.");
      window.location.href = "/new-project";
      return;
    }
    fd.append("lang", document.getElementById("di_lang").value);
    fd.append("model", document.getElementById("di_model").value);
    await startTask("di", "/api/diarize_voice", fd, onDoneDiarize);
  } else {
    const text = document.getElementById("di_text_in").value || "";
    if(!text.trim()){ alert("Wklej tekst wejściowy."); return; }
    fd.append("text", text);
    fd.append("speakers", document.getElementById("di_speakers").value || "2");
    fd.append("method", document.getElementById("di_method").value || "alternate");
    fd.append("mapping_json", document.getElementById("di_map").value || "");
    await startTask("di", "/api/diarize_text", fd, onDoneDiarize);
  }
});

document.getElementById("di_save_txt").addEventListener("click", async ()=>{
  const pid = requireProjectId();
  const text = diBuildRawText();
  await api(`/api/projects/${pid}/save_diarized`, {
    method:"POST",
    headers:{ "content-type":"application/json" },
    body: JSON.stringify({ text })
  });
  alert("Zapisano wynik diaryzacji w projekcie.");
});

// Modal bindings
document.getElementById("di_modal_close").addEventListener("click", diCloseModal);
document.getElementById("di_modal_back").addEventListener("click", diCloseModal);
document.getElementById("di_m_cancel").addEventListener("click", diCloseModal);

document.getElementById("di_m_play").addEventListener("click", ()=>{
  if(DI.editIdx>=0) diPlaySegment(DI.editIdx, true);
});
document.getElementById("di_m_pause").addEventListener("click", ()=>{
  if(DI.audio) DI.audio.pause();
});
document.getElementById("di_m_stop").addEventListener("click", ()=>{
  if(DI.editIdx<0 || !DI.audio) return;
  const seg = DI.segments[DI.editIdx];
  DI.audio.pause();
  DI.audio.currentTime = Math.max(0, Number(seg.start)||0);
});
document.getElementById("di_m_save").addEventListener("click", ()=>{
  if(DI.editIdx<0) return;
  const seg = DI.segments[DI.editIdx];
  seg.text = String(document.getElementById("di_m_text").value||"").trim();
  const elBody = document.querySelector(`.seg[data-idx='${DI.editIdx}'] .seg-body`);
  const sp = (seg.speaker||"").trim();
  if(elBody) elBody.textContent = (sp ? " " : "") + seg.text;
  diSetRawTextarea();
  diCloseModal();
});

document.getElementById("di_apply_map").addEventListener("click", ()=>{
  let mapping = {};
  const raw = document.getElementById("di_speaker_map").value || "";
  if(raw.trim()){
    try{ mapping = JSON.parse(raw); }catch(e){ alert("Niepoprawny JSON mapowania."); return; }
  }
  if(DI.segments && DI.segments.length){
    for(const seg of DI.segments){
      const sp = (seg.speaker||"").trim();
      if(sp && Object.prototype.hasOwnProperty.call(mapping, sp)){
        seg.speaker = String(mapping[sp]||sp);
      }
    }
    diRender();
  } else {
    let out = document.getElementById("di_out").value || "";
    for(const [k,v] of Object.entries(mapping)){
      out = out.split(k).join(v);
    }
    document.getElementById("di_out").value = out;
  }
});

document.getElementById("di_save_map").addEventListener("click", async ()=>{
  const pid = requireProjectId();
  const raw = document.getElementById("di_speaker_map").value || "";
  let mapping = {};
  if(raw.trim()){
    try{ mapping = JSON.parse(raw); }catch(e){ alert("Niepoprawny JSON mapowania."); return; }
  }
  await api(`/api/projects/${pid}/speaker_map`, {
    method:"POST",
    headers:{ "content-type":"application/json" },
    body: JSON.stringify({ mapping })
  });
  alert("Zapisano mapowanie w projekcie.");
});

(async()=>{
  await refreshCurrentProjectInfo();
  DI_HAS_AUDIO = !!(AISTATE.projectId && AISTATE.audioFile);
  const btn = document.getElementById("di_btn");
  if(btn){
    // audio is required for audio-based diarization
    const needAudio = (document.getElementById("di_mode")?.value || "pyannote") === "pyannote";
    btn.disabled = needAudio && !(AISTATE.projectId && AISTATE.audioFile);
  }
  await resumeTask("di", onDoneDiarize);

  // Try to load previously saved diarized file (optional)
  try{
    const pid = AISTATE.projectId || "";
    if(pid){
      const txt = await api(`/api/projects/${pid}/download/diarized.txt`);
      const parsed = diSegmentsFromText(txt);
      if(parsed.length){
        DI.segments = parsed;
        diRender();
      } else {
        document.getElementById("di_out").value = txt || "";
      }
    }
  }catch(e){ /* ignore */ }
})();

</script>
{% endblock %}
