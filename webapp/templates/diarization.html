{% extends "base.html" %}
{% block content %}
<style>
  .speaker-mapping-container {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 16px;
    margin-top: 10px;
  }
  
  .speaker-mapping-row {
    display: grid;
    grid-template-columns: 140px 1fr 80px;
    gap: 12px;
    align-items: center;
    margin-bottom: 10px;
    background: white;
    padding: 10px 14px;
    border-radius: 6px;
    border: 1px solid #e0e0e0;
  }
  
  .speaker-mapping-row:hover {
    border-color: #2196F3;
    box-shadow: 0 2px 8px rgba(33, 150, 243, 0.15);
  }
  
  .speaker-label {
    font-family: ui-monospace, monospace;
    font-size: 13px;
    font-weight: 600;
    color: #555;
    background: #f0f0f0;
    padding: 6px 10px;
    border-radius: 4px;
    text-align: center;
  }
  
  .speaker-input {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    transition: all 0.2s;
  }
  
  .speaker-input:focus {
    outline: none;
    border-color: #2196F3;
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
  }
  
  .speaker-count {
    font-size: 12px;
    color: #888;
    text-align: right;
  }
  
  .mapping-empty {
    text-align: center;
    padding: 30px;
    color: #999;
    font-style: italic;
  }
  
  .advanced-toggle {
    margin-top: 12px;
    font-size: 12px;
    color: #666;
    cursor: pointer;
    user-select: none;
  }
  
  .advanced-toggle:hover {
    color: #2196F3;
  }
  
  .json-editor {
    display: none;
    margin-top: 10px;
  }
  
  .json-editor.show {
    display: block;
  }
  
  #speaker_toast {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(33, 150, 243, 0.95);
    color: white;
    padding: 12px 18px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }
  
  /* Diarization blocks styling (like transcription) */
  .blocklist {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .seg {
    padding: 12px 16px;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    cursor: pointer;
    transition: all 0.2s;
  }
  
  .seg:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    transform: translateY(-1px);
  }
  
  .seg-active {
    border-color: #2196F3;
    box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
  }
  
  .seg-time {
    font-size: 11px;
    color: #888;
    margin-bottom: 4px;
    font-family: ui-monospace, monospace;
  }
  
  .seg-speaker {
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 6px;
    padding: 3px 8px;
    border-radius: 4px;
    display: inline-block;
  }
  
  .seg-text {
    font-size: 14px;
    line-height: 1.5;
    color: #333;
  }
  
  /* Speaker colors - pastel palette */
  .speaker-0 { background-color: #E3F2FD; } /* Light Blue */
  .speaker-1 { background-color: #F3E5F5; } /* Light Purple */
  .speaker-2 { background-color: #E8F5E9; } /* Light Green */
  .speaker-3 { background-color: #FFF3E0; } /* Light Orange */
  .speaker-4 { background-color: #FCE4EC; } /* Light Pink */
  .speaker-5 { background-color: #F1F8E9; } /* Light Lime */
  .speaker-6 { background-color: #E0F2F1; } /* Light Teal */
  .speaker-7 { background-color: #FFF9C4; } /* Light Yellow */
  .speaker-8 { background-color: #FFEBEE; } /* Light Red */
  .speaker-9 { background-color: #EDE7F6; } /* Light Deep Purple */
</style>

<div class="card">
  <h1 class="h1" data-i18n="page.diarization.title">Diarization</h1>

  <div class="topgrid">
    <div class="subcard">
      <div class="label" data-i18n="di.label.mode">Tryb</div>
      <select id="di_mode">
        <option value="pyannote" data-i18n="di.mode.pyannote">pyannote (audio)</option>
        <option value="text" data-i18n="di.mode.text">diaryzacja tekstu (prosta)</option>
      </select>
      <div class="small" data-i18n-html="di.hint.pyannote_html">Tryb <b>pyannote</b> wymaga tokena HF (w Ustawieniach).</div>

      <div class="hr"></div>

      <div id="di_pyannote_block">
        <div class="grid" style="grid-template-columns: 1fr 1fr">
          <div>
            <div class="label" data-i18n="di.label.language">Jƒôzyk</div>
            <select id="di_lang">
              <option value="auto">auto</option>
              <option value="pl">pl</option>
              <option value="en">en</option>
              <option value="de">de</option>
              <option value="fr">fr</option>
              <option value="es">es</option>
              <option value="uk">uk</option>
              <option value="ru">ru</option>
            </select>
          </div>
          <div>
            <div class="label" data-i18n="di.label.model_segments">Model Whisper (do segment√≥w)</div>
            <select id="di_model">
              {% for m in whisper_models %}
              <option value="{{m}}" {% if m==default_whisper_model %}selected{% endif %}>{{m}}</option>
              {% endfor %}
            </select>
          </div>
        </div>

        <div class="hr"></div>
      </div>

      <div id="di_text_block" style="display:none">
        <div class="label" data-i18n="di.label.input_text">Tekst wej≈õciowy</div>
        <textarea id="di_text_in" style="min-height:140px" data-i18n-placeholder="di.placeholder.input_text" placeholder="Wklej tekst do prostej diaryzacji‚Ä¶"></textarea>

        <div class="hr"></div>

        <div class="grid" style="grid-template-columns: 1fr 1fr">
          <div>
            <div class="label" data-i18n="di.label.speaker_count">Liczba m√≥wc√≥w</div>
            <input class="input" id="di_speakers" type="number" min="1" max="20" value="2"/>
          </div>
          <div>
            <div class="label" data-i18n="di.label.method">Metoda</div>
            <select id="di_method">
              <option value="alternate" data-i18n="di.method.alternate">naprzemiennie</option>
              <option value="block" data-i18n="di.method.block">blokami</option>
              <option value="lines" data-i18n="di.method.lines">po liniach</option>
              <option value="sentences" data-i18n="di.method.sentences">po zdaniach</option>
              <option value="sentences+merge" data-i18n="di.method.sentences_merge">zdania + ≈ÇƒÖczenie</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="label" data-i18n="di.label.mapping_json">Mapowanie m√≥wc√≥w (JSON)</div>
        <textarea id="di_map" style="min-height:90px" data-i18n-placeholder="di.placeholder.mapping_json" placeholder='np. {"SPK1":"Jan","SPK2":"Anna"}'></textarea>
        <div class="small" data-i18n-html="di.hint.mapping_optional_html">Opcjonalnie: podmie≈Ñ etykiety <code>SPK1</code>, <code>SPK2</code> itd. na imiona.</div>
      </div>

      <div class="hr"></div>

      <div class="label">
        <span data-i18n="di.label.speaker_names">Nazwy m√≥wc√≥w</span>
        <span style="font-weight:normal;font-size:12px;color:#888;margin-left:8px;">
          <span data-i18n="di.speaker_names.detected">(wykryte automatycznie)</span>
        </span>
      </div>
      
      <div id="speaker_mapping_ui" class="speaker-mapping-container">
        <div class="mapping-empty">
          <span data-i18n="di.mapping.empty">Wykonaj diaryzacjƒô aby wykryƒá m√≥wc√≥w üé§</span>
        </div>
      </div>
      
      <div class="advanced-toggle" id="toggle_json_editor">
        <span data-i18n="di.advanced.toggle">‚öôÔ∏è Zaawansowane: edycja JSON</span>
      </div>
      
      <div id="json_editor_container" class="json-editor">
        <textarea id="di_speaker_map" style="min-height:120px;font-family:monospace;font-size:12px;" placeholder='{"SPEAKER_00":"Jan","SPEAKER_01":"Anna"}'></textarea>
        <div class="small" style="margin-top:6px">
          <span data-i18n="di.advanced.warning">‚ö†Ô∏è Uwaga: rƒôczna edycja JSON - b≈Çƒôdy sk≈Çadniowe spowodujƒÖ problemy.</span>
          <button class="btn secondary" style="margin-left:10px;padding:4px 10px;font-size:12px;" id="sync_from_json">
            <span data-i18n="di.advanced.load_json">Za≈Çaduj z JSON</span>
          </button>
        </div>
      </div>

      <div class="row" style="margin-top:14px; flex-wrap:wrap">
        <button class="btn" id="di_apply_map" data-i18n="di.btn.apply_map" data-i18n-title="di.title.apply_map" title="Zamie≈Ñ wszystkie wystƒÖpienia w wyniku">
          ‚úì Zastosuj mapowanie
        </button>
        <button class="btn secondary" id="di_save_map" data-i18n="di.btn.save_map" data-i18n-title="di.title.save_map" title="Zapisz mapowanie w project.json">
          üíæ Zapisz mapowanie
        </button>
        <button class="btn secondary" id="di_refresh_map" data-i18n="di.btn.refresh_map" data-i18n-title="di.title.refresh_map" title="Wykryj m√≥wc√≥w z wyniku">
          üîÑ Od≈õwie≈º z wyniku
        </button>
      </div>
      
      <div class="small" style="margin-top:10px" data-i18n-html="di.how_use_html">
        <strong>Jak u≈ºyƒá:</strong> Wpisz imiona w pola obok etykiet ‚Üí Kliknij <strong>Zastosuj mapowanie</strong> ‚Üí Wszystkie wystƒÖpienia zostanƒÖ zamienione
      </div>
    </div>

    <div class="subcard">
      <div class="row" style="flex-wrap:wrap">
        <button class="btn" id="di_btn" data-i18n="btn.diarize">Diaryzuj</button>
        <a class="btn secondary" id="di_download" href="#" style="display:none" data-i18n="di.btn.download_txt">Pobierz TXT</a>
      </div>

      <div class="small" style="margin-top:10px">
        <span data-i18n="common.status">Status</span>: <b id="di_status">‚Äî</b> ‚Ä¢ <span data-i18n="common.progress">Postƒôp</span>: <span id="di_pct">0%</span>
      </div>
      <div class="progress" style="margin-top:10px"><div id="di_bar"></div></div>
      <div class="small" style="margin-top:10px" data-i18n-html="common.logs_in_tab_html">Logi sƒÖ dostƒôpne w zak≈Çadce <b>Logi</b>.</div>
    </div>
  </div>

  <div class="hr"></div>

  <div class="label" data-i18n="di.label.result">Wynik diaryzacji</div>
  <div class="small" style="margin-bottom:8px" data-i18n="di.hint.hover">Najed≈∫ myszkƒÖ na blok aby ods≈Çuchaƒá fragment ‚Ä¢ Prawy przycisk myszy na bloku: edycja.</div>
  <div id="di_blocks" class="blocklist" style="display:none"></div>
  <textarea id="di_out" class="bigarea" data-i18n-placeholder="di.placeholder.result" placeholder="Tutaj pojawi siƒô wynik‚Ä¶"></textarea>
  <div class="row" style="margin-top:10px; flex-wrap:wrap">
    <button class="btn secondary" id="di_save_txt" data-i18n="di.btn.save_result" data-i18n-title="di.title.save_result" title="Zapisuje bie≈ºƒÖcy tekst do diarized.txt w projekcie">
      üíæ Zapisz wynik w projekcie
    </button>
  </div>
  <div class="small" style="margin-top:6px" data-i18n-html="di.hint.important_html">
    <strong>Wa≈ºne:</strong> Je≈õli zastosowa≈Çe≈õ mapowanie nazw, pamiƒôtaj ≈ºeby zapisaƒá wynik! 
    Inaczej przy ponownym za≈Çadowaniu bƒôdƒÖ oryginalne etykiety.
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
"use strict";

// ========== Diarization State ==========
const DI = {
  segments: [],
  audio: null,
  audioUrl: "",
  activeIdx: -1,
  endWatch: null,
  speakerColors: {}
};

// ========== Helper Functions ==========

// Parse diarization line: [12.34-15.67] SPEAKER_00: text
function parseDiarizedLine(line){
  const m = line.match(/^\s*\[(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\]\s*([A-Za-z0-9_\-]+)\s*:\s*(.*)$/);
  if(!m) return null;
  return {
    start: parseFloat(m[1]),
    end: parseFloat(m[2]),
    speaker: m[3].trim(),
    text: m[4].trim()
  };
}

// Parse entire diarized text into segments
function parseDiarizedText(text){
  const segments = [];
  const lines = String(text || "").split(/\r?\n/);
  for(const line of lines){
    const seg = parseDiarizedLine(line);
    if(seg) segments.push(seg);
  }
  return segments;
}

// Format timestamp for display
function formatTime(sec){
  const s = Math.max(0, Number(sec)||0);
  const mm = Math.floor(s / 60);
  const ss = (s % 60).toFixed(3);
  return mm + ":" + String(ss).padStart(6,'0');
}

// Get audio URL
function diAudioUrl(){
  const pid = AISTATE.projectId || "";
  const f = AISTATE.audioFile || "";
  if(!pid || !f) return "";
  return "/api/projects/" + pid + "/download/" + encodeURIComponent(f);
}

// Stop playback
function diStopPlayback(){
  if(DI.endWatch){ clearInterval(DI.endWatch); DI.endWatch=null; }
  if(DI.audio){ try{ DI.audio.pause(); }catch(e){} }
  if(DI.activeIdx>=0){
    const old = document.querySelector(".seg[data-idx='" + DI.activeIdx + "']");
    if(old) old.classList.remove("seg-active");
  }
  DI.activeIdx = -1;
}

// Play segment
function diPlaySegment(idx, fromStart){
  if(fromStart === undefined) fromStart = true;
  if(!DI.audio || !DI.audioUrl) return;
  const seg = DI.segments[idx];
  if(!seg) return;

  diStopPlayback();
  DI.activeIdx = idx;
  const elSeg = document.querySelector(".seg[data-idx='" + idx + "']");
  if(elSeg) elSeg.classList.add("seg-active");

  const endT = Math.max(0, Number(seg.end)||0);
  const startT = Math.max(0, Number(seg.start)||0);
  if(fromStart || DI.audio.currentTime < startT || DI.audio.currentTime > endT){
    DI.audio.currentTime = startT;
  }
  DI.audio.play().catch(function(){});

  DI.endWatch = setInterval(function(){
    if(!DI.audio) return;
    if(DI.audio.currentTime >= (endT - 0.02)){
      try{ DI.audio.pause(); }catch(e){}
      clearInterval(DI.endWatch);
      DI.endWatch = null;
    }
  }, 50);
}

// Assign color to speaker
function getSpeakerColor(speaker){
  if(!DI.speakerColors[speaker]){
    const idx = Object.keys(DI.speakerColors).length % 10;
    DI.speakerColors[speaker] = "speaker-" + idx;
  }
  return DI.speakerColors[speaker];
}

// Build raw text from segments
function diBuildRawText(){
  if(!DI.segments || !DI.segments.length){
    return document.getElementById("di_out").value || "";
  }
  return DI.segments.map(function(s){
    return "[" + s.start.toFixed(2) + "-" + s.end.toFixed(2) + "] " + s.speaker + ": " + s.text;
  }).join("\n");
}

// Update textarea with current segments
function diSetRawTextarea(){
  document.getElementById("di_out").value = diBuildRawText();
}

// Render blocks
function diRender(){
  const blocks = document.getElementById("di_blocks");
  const ta = document.getElementById("di_out");
  
  if(!DI.segments || DI.segments.length === 0){
    blocks.style.display = "none";
    ta.style.display = "block";
    return;
  }
  
  blocks.style.display = "flex";
  ta.style.display = "none";
  blocks.innerHTML = "";

  DI.audioUrl = diAudioUrl();
  if(DI.audioUrl){
    if(!DI.audio){
      DI.audio = new Audio();
      DI.audio.preload = "metadata";
    }
    DI.audio.src = DI.audioUrl;
  }

  DI.segments.forEach(function(seg, idx){
    const d = document.createElement("div");
    d.className = "seg " + getSpeakerColor(seg.speaker);
    d.dataset.idx = String(idx);
    
    d.innerHTML='<div class="seg-time">'+formatTime(seg.start)+' ‚Üí '+formatTime(seg.end)+' <strong>'+seg.speaker+'</strong></div>' +
                  '<div class="seg-text"></div>';
    d.querySelector(".seg-text").textContent = seg.text || "";

    d.addEventListener("mouseenter", function(){ diPlaySegment(idx, true); });
    d.addEventListener("mouseleave", function(){ diStopPlayback(); });
    
    blocks.appendChild(d);
  });
  
  diSetRawTextarea();
}

// Extract speaker labels from diarization output
function extractSpeakerLabels(text){
  const labels = new Set();
  String(text || "").split(/\r?\n/).forEach(function(line){
    const cleaned = line.replace(/^\s*\[[\d\.\-]+\]\s*/, '');
    const m = cleaned.match(/^\s*([A-Za-z0-9_\-]{1,40})\s*:/);
    if(m && m[1]) {
      labels.add(m[1].trim());
    }
  });
  
  const result = Array.from(labels).sort();
  console.log('üîç Znalezione etykiety m√≥wc√≥w:', result);
  return result;
}

// Count occurrences of a speaker label in text
function countSpeakerOccurrences(text, label){
  const escaped = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const matches = text.match(new RegExp(escaped, 'g'));
  return matches ? matches.length : 0;
}

// Show temporary toast notification
function showToast(message, duration){
  if(duration === undefined) duration = 2000;
  let toast = document.getElementById('speaker_toast');
  if(!toast){
    toast = document.createElement('div');
    toast.id = 'speaker_toast';
    document.body.appendChild(toast);
  }
  
  toast.textContent = message;
  toast.style.opacity = '1';
  
  clearTimeout(toast._timer);
  toast._timer = setTimeout(function(){
    toast.style.opacity = '0';
  }, duration);
}

// Render speaker mapping UI
function renderSpeakerMappingUI(labels, outputText){
  const container = document.getElementById('speaker_mapping_ui');
  if(!container) return;
  
  if(!labels || labels.length === 0){
    container.innerHTML = '<div class="mapping-empty">' + t('di.mapping.empty') + '</div>';
    return;
  }
  
  let currentMapping = {};
  try{
    const raw = document.getElementById('di_speaker_map').value || '';
    if(raw.trim()) currentMapping = JSON.parse(raw);
  }catch(e){}
  
  container.innerHTML = '';
  
  labels.forEach(function(label){
    const row = document.createElement('div');
    row.className = 'speaker-mapping-row';
    
    const labelEl = document.createElement('div');
    labelEl.className = 'speaker-label';
    labelEl.textContent = label;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'speaker-input';
    input.value = currentMapping[label] || label;
    input.placeholder = tFmt('di.placeholder.speaker_name', {label});
    input.dataset.speaker = label;
    
    input.addEventListener('input', syncToJSON);
    
    const countEl = document.createElement('div');
    countEl.className = 'speaker-count';
    if(outputText){
      const count = countSpeakerOccurrences(outputText, label);
      countEl.textContent = count > 0 ? (count + '√ó') : '';
    }
    
    row.appendChild(labelEl);
    row.appendChild(input);
    row.appendChild(countEl);
    container.appendChild(row);
  });
  
  console.log('‚úÖ Wygenerowano UI dla ' + labels.length + ' m√≥wc√≥w');
  showToast(tFmt('di.toast.updated_speakers', {count: labels.length}));
}

// Sync UI inputs to hidden JSON textarea
function syncToJSON(){
  const inputs = document.querySelectorAll('.speaker-input');
  const mapping = {};
  
  inputs.forEach(function(input){
    const label = input.dataset.speaker;
    const value = input.value.trim() || label;
    mapping[label] = value;
  });
  
  const jsonTextarea = document.getElementById('di_speaker_map');
  if(jsonTextarea){
    jsonTextarea.value = JSON.stringify(mapping, null, 2);
  }
  
  console.log('üîÑ Zsynchronizowano mapowanie do JSON:', mapping);
}

// Sync JSON textarea to UI inputs
function syncFromJSON(){
  try{
    const raw = document.getElementById('di_speaker_map').value || '';
    if(!raw.trim()) return;
    
    const mapping = JSON.parse(raw);
    const inputs = document.querySelectorAll('.speaker-input');
    
    inputs.forEach(function(input){
      const label = input.dataset.speaker;
      if(mapping[label] !== undefined){
        input.value = mapping[label];
      }
    });
    
    console.log('‚úÖ Za≈Çadowano mapowanie z JSON do UI');
    alert(t("di.alert.map_loaded"));
  }catch(e){
    alert(tFmt("di.alert.json_parse_error", {msg: e.message}));
  }
}

// Merge speaker map (preserves manual names)
function mergeSpeakerMap(labels){
  const ta = document.getElementById("di_speaker_map");
  if(!ta) return;

  let current = {};
  const raw = (ta.value || "").trim();
  
  if(raw){
    try{
      const j = JSON.parse(raw);
      if(j && typeof j === "object" && !Array.isArray(j)){
        current = j;
      }
    }catch(e){
      console.warn('‚ö†Ô∏è Niepoprawny JSON w mapowaniu, tworzƒô nowy:', e.message);
      current = {};
    }
  }

  let changed = false;
  for(let i=0; i<labels.length; i++){
    const lab = labels[i];
    if(!(lab in current)){
      current[lab] = lab;
      changed = true;
      console.log('‚ûï Dodano nowƒÖ etykietƒô do mapowania:', lab);
    } else {
      console.log('‚úì Zachowano istniejƒÖcƒÖ nazwƒô dla:', lab, '‚Üí', current[lab]);
    }
  }

  if(changed || !raw){
    ta.value = JSON.stringify(current, null, 2);
    console.log('‚úÖ Zaktualizowano mapowanie m√≥wc√≥w:', current);
  }
  
  const outText = document.getElementById('di_out') ? (document.getElementById('di_out').value || '') : '';
  renderSpeakerMappingUI(labels, outText);
}

function setDownloadLink(projectId){
  const dl = document.getElementById("di_download");
  if(!dl) return;
  dl.href = "/api/projects/" + projectId + "/download/diarized.txt";
  dl.style.display = "inline-flex";
}

let DI_HAS_AUDIO = false;

async function updateAudioState(){
  await refreshCurrentProjectInfo();
  DI_HAS_AUDIO = Boolean(AISTATE.projectId && AISTATE.audioFile);
  const btn = document.getElementById("di_btn");
  if(btn){
    const modeEl = document.getElementById("di_mode");
    const mode = modeEl ? (modeEl.value || "pyannote") : "pyannote";
    const needAudio = (mode === "pyannote");
    btn.disabled = needAudio && !DI_HAS_AUDIO;
  }
}

async function loadProjectJson(projectId){
  try{
    const raw = await api("/api/projects/" + projectId + "/download/project.json");
    return JSON.parse(String(raw || "{}"));
  }catch(e){
    return {};
  }
}

const LS = {
  get: function(key){ try{ return localStorage.getItem(key); }catch(e){ return null; } },
  set: function(key,val){ try{ localStorage.setItem(key, val); }catch(e){} }
};

function draftKeys(projectId){
  return {
    diarized: "aistateweb:draft:diarized:" + projectId,
    speakerMap: "aistateweb:draft:speaker_map:" + projectId
  };
}

function setupDraftAutosave(projectId){
  const keys = draftKeys(projectId);

  const out = document.getElementById("di_out");
  if(out){
    out.addEventListener("input", function(){
      LS.set(keys.diarized, out.value || "");
    });
  }

  const sm = document.getElementById("di_speaker_map");
  if(sm){
    sm.addEventListener("input", function(){
      LS.set(keys.speakerMap, sm.value || "");
    });
  }
}

async function restoreOutputs(projectId){
  const keys = draftKeys(projectId);

  const out = document.getElementById("di_out");
  const sm = document.getElementById("di_speaker_map");

  const draftOut = LS.get(keys.diarized);
  if(out && !out.value.trim() && draftOut && String(draftOut).trim()){
    out.value = String(draftOut);
  }

  const draftMap = LS.get(keys.speakerMap);
  if(sm && !sm.value.trim() && draftMap && String(draftMap).trim()){
    sm.value = String(draftMap);
  }

  const meta = await loadProjectJson(projectId);

  if(sm && !sm.value.trim() && meta && typeof meta === "object" && meta.speaker_map){
    try{
      sm.value = JSON.stringify(meta.speaker_map, null, 2);
    }catch(e){}
  }

  if(out && !out.value.trim()){
    try{
      const txt = await api("/api/projects/" + projectId + "/download/diarized.txt");
      if(txt && String(txt).trim()){
        out.value = String(txt);
        setDownloadLink(projectId);
      }
    }catch(e){}
  }

  if(out && out.value.trim()){
    console.log('üîÑ Od≈õwie≈ºam mapowanie z za≈Çadowanego wyniku...');
    
    const segments = parseDiarizedText(out.value);
    if(segments.length){
      DI.segments = segments;
      diRender();
      console.log('‚úÖ Wyrenderowano ' + segments.length + ' blok√≥w z zapisanego wyniku');
    }
    
    const labels = extractSpeakerLabels(out.value);
    if(labels.length) {
      mergeSpeakerMap(labels);
    }
  }
}

function onDoneDiarize(j){
  console.log('‚úÖ Diaryzacja zako≈Ñczona, przetwarzam wynik...');
  
  if(j.result && j.result.text){
    const out = j.result.text;
    const outEl = document.getElementById("di_out");
    if(outEl) {
      outEl.value = out;
      console.log('üìù Wynik diaryzacji zapisany do pola tekstowego');
    }

    const segments = parseDiarizedText(out);
    if(segments.length){
      DI.segments = segments;
      diRender();
      console.log('‚úÖ Wyrenderowano ' + segments.length + ' blok√≥w');
    }

    console.log('üîç Wykrywam m√≥wc√≥w z wyniku...');
    const labels = extractSpeakerLabels(out);
    
    if(labels.length) {
      console.log('‚úÖ Znaleziono ' + labels.length + ' m√≥wc√≥w:', labels);
      mergeSpeakerMap(labels);
    } else {
      console.warn('‚ö†Ô∏è Nie znaleziono ≈ºadnych etykiet m√≥wc√≥w');
    }

    if(AISTATE.projectId){
      const keys = draftKeys(AISTATE.projectId);
      LS.set(keys.diarized, out);
    }

    if(j.project_id){
      setDownloadLink(j.project_id);
    }
  }
}

function toggleMode(){
  const mode = document.getElementById("di_mode").value;
  document.getElementById("di_pyannote_block").style.display = (mode==="pyannote") ? "block" : "none";
  document.getElementById("di_text_block").style.display = (mode==="text") ? "block" : "none";
  updateAudioState();
}

// ========== Event Listeners ==========

document.getElementById("di_mode").addEventListener("change", toggleMode);
toggleMode();

document.getElementById("di_btn").addEventListener("click", async function(){
  const mode = document.getElementById("di_mode").value;
  const fd = new FormData();

  if(mode === "pyannote"){
    await updateAudioState();
    if(!DI_HAS_AUDIO){
      alert(t("di.alert.no_audio"));
      window.location.href = "/new-project";
      return;
    }
    fd.append("lang", document.getElementById("di_lang").value);
    fd.append("model", document.getElementById("di_model").value);
    await startTask("di", "/api/diarize_voice", fd, onDoneDiarize);
  } else {
    const text = document.getElementById("di_text_in").value || "";
    if(!text.trim()){ alert(t("di.alert.paste_text")); return; }
    fd.append("text", text);
    fd.append("speakers", document.getElementById("di_speakers").value || "2");
    fd.append("method", document.getElementById("di_method").value || "alternate");
    fd.append("mapping_json", document.getElementById("di_map").value || "");
    await startTask("di", "/api/diarize_text", fd, onDoneDiarize);
  }
});

document.getElementById("di_save_txt").addEventListener("click", async function(){
  const pid = requireProjectId();
  const text = diBuildRawText();
  
  if(!text.trim()){
    alert(t("di.alert.empty_output"));
    return;
  }
  
  await api("/api/projects/" + pid + "/save_diarized", {
    method:"POST",
    headers:{ "content-type":"application/json" },
    body: JSON.stringify({ text: text })
  });

  setDownloadLink(pid);
  const keys = draftKeys(pid);
  LS.set(keys.diarized, text);

  const hasMapping = text.includes("SPEAKER_");
  const hint = hasMapping 
    ? t("di.hint.speaker_labels")
    : "";
    
  alert(tFmt("di.alert.saved_output", {hint}));
});

document.getElementById("di_apply_map").addEventListener("click", function(){
  syncToJSON();
  
  let mapping = {};
  const raw = document.getElementById("di_speaker_map").value || "";
  if(raw.trim()){
    try{ mapping = JSON.parse(raw); }catch(e){ alert(t("di.alert.bad_json")); return; }
  }
  
  const outEl = document.getElementById("di_out");
  let out = outEl.value || "";
  
  let totalReplacements = 0;
  const details = [];
  
  for(const k in mapping){
    if(!mapping.hasOwnProperty(k)) continue;
    const v = mapping[k];
    if(k === v) continue;
    const count = (out.match(new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
    if(count > 0){
      out = out.split(k).join(v);
      totalReplacements += count;
      details.push(k + ' ‚Üí ' + v + ' (' + count + '√ó)');
    }
  }
  
  outEl.value = out;
  
  if(totalReplacements > 0){
    console.log('‚úÖ Zastosowano mapowanie m√≥wc√≥w:', details.join(', '));
    
    const segments = parseDiarizedText(out);
    if(segments.length){
      DI.segments = segments;
      DI.speakerColors = {};
      diRender();
    }
    
    const labels = extractSpeakerLabels(out);
    renderSpeakerMappingUI(labels, out);
    
    alert(tFmt("di.alert.applied_map", {details: details.join("\n"), total: totalReplacements}));
  } else {
    alert(t("di.alert.no_replacements"));
  }
});

document.getElementById("di_save_map").addEventListener("click", async function(){
  syncToJSON();
  
  const pid = requireProjectId();
  const raw = document.getElementById("di_speaker_map").value || "";
  let mapping = {};
  if(raw.trim()){
    try{ mapping = JSON.parse(raw); }catch(e){ alert(t("di.alert.bad_json")); return; }
  }
  
  await api("/api/projects/" + pid + "/speaker_map", {
    method:"POST",
    headers:{ "content-type":"application/json" },
    body: JSON.stringify({ mapping: mapping })
  });

  const keys = draftKeys(pid);
  LS.set(keys.speakerMap, JSON.stringify(mapping, null, 2));

  const count = Object.keys(mapping).length;
  alert(tFmt("di.alert.saved_map", {count}));
});

document.getElementById("di_refresh_map").addEventListener("click", function(){
  const outEl = document.getElementById("di_out");
  if(!outEl || !outEl.value.trim()){
    alert(t("di.alert.need_diarize"));
    return;
  }
  
  console.log('üîÑ Rƒôczne od≈õwie≈ºanie mapowania...');
  const labels = extractSpeakerLabels(outEl.value);
  
  if(labels.length){
    mergeSpeakerMap(labels);
    
    const segments = parseDiarizedText(outEl.value);
    if(segments.length){
      DI.segments = segments;
      diRender();
    }
    
    alert(tFmt("di.alert.found_speakers", {count: labels.length, list: labels.join(", ")}));
  } else {
    alert(t("di.alert.no_speaker_labels"));
  }
});

document.getElementById("toggle_json_editor").addEventListener("click", function(){
  const container = document.getElementById("json_editor_container");
  container.classList.toggle("show");
  
  const toggle = document.getElementById("toggle_json_editor");
  if(container.classList.contains("show")){
    toggle.textContent = "‚öôÔ∏è Zaawansowane: ukryj JSON";
  } else {
    toggle.textContent = "‚öôÔ∏è Zaawansowane: edycja JSON";
  }
});

document.getElementById("sync_from_json").addEventListener("click", syncFromJSON);

document.addEventListener('aistate:output-updated', function(e){
  console.log('üîî Received output-updated event:', e.detail);
  
  if(e.detail && e.detail.textareaId === 'di_out'){
    const outEl = document.getElementById("di_out");
    if(outEl && outEl.value.trim()){
      console.log('üîÑ Auto-refreshing speaker mapping and blocks from updated output...');
      
      const segments = parseDiarizedText(outEl.value);
      if(segments.length){
        DI.segments = segments;
        diRender();
        console.log('‚úÖ Re-rendered ' + segments.length + ' blocks');
      }
      
      const labels = extractSpeakerLabels(outEl.value);
      if(labels.length){
        mergeSpeakerMap(labels);
        showToast('‚úÖ Wykryto ' + labels.length + ' m√≥wc√≥w');
        console.log('‚úÖ Auto-refresh complete: ' + labels.length + ' speakers found:', labels);
      } else {
        console.warn('‚ö†Ô∏è No speaker labels found in output');
      }
    }
  }
});

// Export global helpers for app.js integration
window.DI = DI;
window.diRender = diRender;
window.diBuildRawText = diBuildRawText;
window.parseDiarizedText = parseDiarizedText;
window.diStopPlayback = diStopPlayback;

(async function(){
  await updateAudioState();
  if(AISTATE.projectId){
    setupDraftAutosave(AISTATE.projectId);
    await restoreOutputs(AISTATE.projectId);
  }
  await resumeTask("di", onDoneDiarize);
})();
</script>
{% endblock %}