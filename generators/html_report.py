from __future__ import annotations

import html
import re
from typing import Any, Dict, List, Tuple


DEFAULT_PROGRAM = "AISTATEwww"
DEFAULT_AUTHOR_EMAIL = "pawlict@proton.me"
DEFAULT_LICENSE_NAME = "MIT License (AS IS)"

# Accept:
# [00:01.23–00:05.67] SPEAKER_00 [MUZYKA]: tekst...
# [0.00-11.00] SPEAKER_00: tekst...
_TS_RE = re.compile(r"^\[(?P<a>[0-9:.,]+)\s*[-–]\s*(?P<b>[0-9:.,]+)\]\s*(?P<rest>.*)$")
_SPK_RE = re.compile(r"^(?P<spk>[^:\[\]]{1,64}):\s*(?P<txt>.*)$")
_SPK_TAGS_RE = re.compile(
    r"^(?P<spk>[A-Za-z0-9_]+)\s*(?P<tags>(?:\[[^\]]+\]\s*)*)\s*:?\s*(?P<txt>.*)$"
)


def _lines(x: Any) -> List[str]:
    if x is None:
        return []
    if isinstance(x, list):
        return [str(i) for i in x]
    return str(x).splitlines()


def _esc(s: Any) -> str:
    return html.escape("" if s is None else str(s), quote=False)


def _ui_labels(ui_lang: str) -> Dict[str, str]:
    ui_lang = (ui_lang or "pl").lower()
    if ui_lang.startswith("en"):
        return {
            "author": "Author",
            "processed": "Processed",
            "file": "File",
            "models": "Model",
            "speakers": "Speakers",
            "segments": "Segments",
            "talk": "Talk time",
            "nonverbal": "Non-verbal",
            "export": "Export format",
            "logs": "LOGS",
            "diary": "Diarization",
            "generated": "Generated by",
            "license": "License",
        }
    return {
        "author": "Autor",
        "processed": "Przetworzono",
        "file": "Plik",
        "models": "Model",
        "speakers": "Liczba speakerów",
        "segments": "Segmenty",
        "talk": "Czas mówienia",
        "nonverbal": "Non-verbal",
        "export": "Format eksportu",
        "logs": "LOGI",
        "diary": "Diaryzacja",
        "generated": "Wygenerowano przez",
        "license": "Licencja",
    }


def _extract_speaker(line_rest: str) -> Tuple[str, List[str], str]:
    m = _SPK_TAGS_RE.match(line_rest.strip())
    if not m:
        m2 = _SPK_RE.match(line_rest.strip())
        if not m2:
            return "", [], line_rest.strip()
        return m2.group("spk").strip(), [], m2.group("txt").strip()

    spk = (m.group("spk") or "").strip()
    tags_raw = (m.group("tags") or "").strip()
    txt = (m.group("txt") or "").strip()

    tags: List[str] = []
    if tags_raw:
        tags = re.findall(r"\[([^\]]+)\]", tags_raw)

    return spk, tags, txt


def _parse_segment_line(line: str) -> Tuple[str, str, List[str], str]:
    line = (line or "").strip()
    if not line:
        return "", "", [], ""

    m = _TS_RE.match(line)
    if m:
        a = m.group("a").strip()
        b = m.group("b").strip()
        rest = (m.group("rest") or "").strip()
        spk, tags, txt = _extract_speaker(rest)
        ts = f"[{a}-{b}]"
        return ts, spk, tags, txt

    spk, tags, txt = _extract_speaker(line)
    return "", spk, tags, txt


def _speaker_palette() -> List[Tuple[str, str, str]]:
    # (bg, border, text)
    return [
        ("#eaf2ff", "#bfd6ff", "#0b2a52"),  # blue
        ("#eaf7ee", "#bfe6c8", "#0f3a1d"),  # green
        ("#fff1e6", "#ffd1ad", "#4a2b12"),  # orange
        ("#f3eaff", "#d9c7ff", "#2c184d"),  # violet
        ("#e9fbff", "#bfeef7", "#083744"),  # cyan
        ("#fff0f6", "#ffc2dd", "#4a1430"),  # pink
    ]


def generate_html_report(data: Dict[str, Any], logs: bool = False, output_path: str = "report.html") -> None:
    ui_lang = (data.get("ui_language") or data.get("lang_ui") or data.get("language") or "pl")
    L = _ui_labels(str(ui_lang))

    program_name = data.get("program_name") or DEFAULT_PROGRAM
    version = data.get("version") or ""
    author = data.get("author") or DEFAULT_AUTHOR_EMAIL
    dt = data.get("datetime") or ""
    lic = data.get("license_name") or DEFAULT_LICENSE_NAME

    audio_file = data.get("audio_file") or ""
    audio_duration = data.get("audio_duration") or ""
    audio_specs = data.get("audio_specs") or ""

    whisper_model = data.get("whisper_model") or ""
    language = data.get("language") or ""
    pyannote_model = data.get("pyannote_model") or ""

    speakers_count = data.get("speakers_count")
    segments_count = data.get("segments_count")
    speaker_times = data.get("speaker_times") or {}

    transcript_lines = _lines(data.get("transcript"))
    non_verbal = _lines(data.get("non_verbal"))
    out_formats = data.get("export_formats") or data.get("formats") or ["TXT", "PDF", "HTML"]

    # Allow UI to override the main section title (e.g., "Transcription" vs "Diarization").
    section_title = (data.get("section_title") or data.get("report_section_title") or "").strip()
    if not section_title:
        section_title = str(L["diary"])

    speakers_seen: List[str] = []
    parsed_segments: List[Tuple[str, str, List[str], str]] = []
    for ln in transcript_lines:
        ts, spk, tags, txt = _parse_segment_line(ln)
        parsed_segments.append((ts, spk, tags, txt))
        if spk and spk not in speakers_seen:
            speakers_seen.append(spk)

    for spk in list(speaker_times.keys()):
        if spk not in speakers_seen:
            speakers_seen.append(spk)

    palette = _speaker_palette()
    spk_to_idx: Dict[str, int] = {spk: (i % len(palette)) for i, spk in enumerate(speakers_seen)}

    speaker_css: List[str] = []
    for spk, idx in spk_to_idx.items():
        bg, border, txtc = palette[idx]
        safe = re.sub(r"[^A-Za-z0-9_]", "_", spk)
        speaker_css.append(f".seg.seg-{safe} {{ background: {bg}; border-color: {border}; color: {txtc}; }}")

    # Gather notes for inline display
    notes = data.get("notes")
    notes_global = ""
    notes_blocks: Dict[str, str] = {}
    if notes and isinstance(notes, dict):
        notes_global = (notes.get("global") or "").strip()
        notes_blocks = notes.get("blocks") or {}

    seg_html: List[str] = []

    # Global note at the top
    if notes_global:
        seg_html.append(
            f'<div class="note-inline"><span class="note-label">Notatka:</span> {_esc(notes_global)}</div>'
        )

    for seg_idx, (ts, spk, tags, txt) in enumerate(parsed_segments):
        safe = re.sub(r"[^A-Za-z0-9_]", "_", spk) if spk else "GEN"
        cls = f"seg seg-{safe}"
        tag_html = ""
        if tags:
            tag_html = " " + " ".join([f"<span class='tag'>[{_esc(t)}]</span>" for t in tags])

        block_note_html = ""
        bn = (notes_blocks.get(str(seg_idx)) or "").strip()
        if bn:
            block_note_html = f'<div class="note-inline"><span class="note-label">Notatka:</span> {_esc(bn)}</div>'

        seg_html.append(
            f"""
            <div class="{cls}">
              <div class="seg-line">
                <span class="ts">{_esc(ts)}</span>
                <span class="spk">{_esc(spk + ':' if spk else '')}</span>
                {tag_html}
              </div>
              <div class="txt">{_esc(txt)}</div>
              {block_note_html}
            </div>
            """
        )

    nv_html = ""
    if non_verbal:
        nv_html = (
            "<div class='extras'><b>"
            + _esc(L["nonverbal"])
            + ":</b> "
            + " ".join([f"[{_esc(x)}]" for x in non_verbal])
            + "</div>"
        )

    fmt_html = ""
    if out_formats:
        fmt_html = "<div class='extras'><b>" + _esc(L["export"]) + ":</b> " + "/".join(
            [str(x).upper() for x in out_formats]
        ) + "</div>"

    logs_html = ""
    if logs and data.get("logs"):
        logs_html = (
            "<details class='logs'><summary>"
            + _esc(L["logs"])
            + "</summary>"
            + f"<pre>{_esc(data.get('logs'))}</pre>"
            + "</details>"
        )

    title = f"{program_name} {version}".strip()

    file_line = audio_file
    if audio_duration or audio_specs:
        parts = []
        if audio_duration:
            parts.append(audio_duration)
        if audio_specs:
            parts.append(audio_specs)
        file_line = f"{audio_file} ({', '.join(parts)})".strip()

    models_line = f"Whisper: {whisper_model} | {L['export'].split()[0] if False else ('Język' if not str(ui_lang).lower().startswith('en') else 'Language')}: {language} | pyannote: {pyannote_model}".strip()

    talk_line = ", ".join([f"{k}={v}" for k, v in speaker_times.items()]) if speaker_times else ""

    style = f"""
    <style>
      :root {{
        --border: #dcdcdc;
        --muted: #555;
      }}
      body {{
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
        margin: 18px;
        color: #111;
        background: #fff;
      }}
      .meta-card {{
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 16px 18px;
        margin-bottom: 18px;
      }}
      .meta-title {{
        font-weight: 800;
        font-size: 18px;
        margin-bottom: 8px;
      }}
      .meta-line {{
        margin: 3px 0;
        line-height: 1.35;
      }}
      .k {{
        color: var(--muted);
      }}

      .section-title {{
        font-weight: 900;
        font-size: 26px;
        margin: 18px 0 12px 0;
        letter-spacing: 0.2px;
      }}

      .seg {{
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
        margin: 10px 0;
      }}
      .seg-line {{
        display: flex;
        gap: 10px;
        align-items: baseline;
        flex-wrap: wrap;
        margin-bottom: 6px;
      }}
      .ts {{
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        opacity: 0.9;
      }}
      .spk {{
        font-weight: 800;
      }}
      .tag {{
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        opacity: 0.85;
      }}
      .txt {{
        white-space: pre-wrap;
      }}

      .extras {{
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px dashed rgba(0,0,0,0.10);
      }}
      details.logs {{
        margin-top: 14px;
      }}
      pre {{
        background: rgba(0,0,0,0.05);
        padding: 10px;
        border-radius: 10px;
        overflow: auto;
      }}

      {" ".join(speaker_css)}

      .note-inline {{
        margin-top: 6px;
        padding: 5px 10px;
        background: #fffbe6;
        border-left: 3px solid #ffb300;
        border-radius: 4px;
        font-size: 0.88em;
        color: #5a4e00;
      }}
      .note-label {{
        font-weight: 700;
        color: #b38600;
      }}

      .footer {{
        margin-top: 14px;
        font-size: 12px;
        opacity: 0.8;
      }}
    </style>
    """

    # label for language line
    lang_label = "Language" if str(ui_lang).lower().startswith("en") else "Język"

    html_doc = f"""<!doctype html>
<html lang="{_esc(ui_lang)}">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>{_esc(title)}</title>
{style}
</head>
<body>

  <div class="meta-card">
    <div class="meta-title">{_esc(title)}</div>
    <div class="meta-line"><span class="k">{_esc(L["author"])}:</span> {_esc(author)}</div>
    <div class="meta-line"><span class="k">{_esc(L["processed"])}:</span> {_esc(dt)}</div>
    <div class="meta-line"><span class="k">{_esc(L["file"])}:</span> {_esc(file_line)}</div>
    <div class="meta-line"><span class="k">{_esc(L["models"])}:</span> {_esc(f"Whisper: {whisper_model} | {lang_label}: {language} | pyannote: {pyannote_model}")}</div>
    <div class="meta-line"><span class="k">{_esc(L["speakers"])}:</span> {_esc(speakers_count)}</div>
    <div class="meta-line"><span class="k">{_esc(L["segments"])}:</span> {_esc(segments_count)} | <span class="k">{_esc(L["talk"])}:</span> {_esc(talk_line)}</div>
    <div class="meta-line"><span class="k">{_esc(L["export"])}:</span> {"/".join([_esc(str(x).upper()) for x in out_formats])}</div>
  </div>

  <div class="section-title">{_esc(section_title)}</div>

  <div class="segments">
    {''.join(seg_html) if seg_html else '<div class="seg">(brak)</div>'}
    {nv_html}
    {fmt_html}
    {logs_html}
  </div>

  <div class="footer">{_esc(L['generated'])}: {_esc(program_name)} {_esc(version)} • {_esc(L['author'])}: {_esc(author)} • {_esc(L['license'])}: {_esc(lic)} • AS IS</div>

</body>
</html>
"""

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(html_doc)
