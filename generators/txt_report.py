from __future__ import annotations

from typing import Any, Dict, List


DEFAULT_PROGRAM = "AISTATEwww"
DEFAULT_AUTHOR_EMAIL = "pawlict@proton.me"
DEFAULT_LICENSE_NAME = "MIT License (AS IS)"


def _lines_from_transcript(x: Any) -> List[str]:
    if x is None:
        return []
    if isinstance(x, list):
        return [str(i) for i in x]
    s = str(x)
    return [ln for ln in s.splitlines()]


def _labels(ui_lang: str) -> Dict[str, str]:
    ui_lang = (ui_lang or "pl").lower()
    if ui_lang.startswith("en"):
        return {
            "author": "Author",
            "processed": "Processed",
            "file": "File",
            "whisper": "Whisper model",
            "lang": "Language",
            "pyannote": "pyannote model",
            "speakers": "Speakers",
            "segments": "Segments",
            "talk": "Talk time",
            "diary": "=== Diarization ===",
            "nonverbal": "Non-verbal",
            "export": "Export format",
            "logs": "=== LOGS ===",
            "generated": "Generated by",
            "license": "License",
        }
    return {
        "author": "Autor",
        "processed": "Przetworzono",
        "file": "Plik",
        "whisper": "Model Whisper",
        "lang": "Język",
        "pyannote": "Model pyannote",
        "speakers": "Liczba speakerów",
        "segments": "Segmenty",
        "talk": "Czas mówienia",
        "diary": "=== Diaryzacja ===",
        "nonverbal": "Non-verbal",
        "export": "Format eksportu",
        "logs": "=== LOGI ===",
        "generated": "Wygenerowano przez",
        "license": "Licencja",
    }


def generate_txt_report(data: Dict[str, Any], logs: bool = False, output_path: str = "") -> None:
    """
    Generate a clean text report (PL/EN based on ui_language).
    Keys (best-effort): program_name, version, author, datetime, audio_file, audio_duration, audio_specs,
    whisper_model, language, pyannote_model, speakers_count, segments_count, speaker_times, transcript, non_verbal.
    """
    ui_lang = str(data.get("ui_language") or data.get("lang_ui") or "pl")
    L = _labels(ui_lang)

    section_title = (data.get("section_title") or data.get("report_section_title") or "").strip()
    if not section_title:
        section_title = str(L["diary"])

    program_line = f"{data.get('program_name') or DEFAULT_PROGRAM} {data.get('version','')}".strip()
    author_line = (data.get("author") or DEFAULT_AUTHOR_EMAIL).strip()

    speaker_times = data.get("speaker_times") or {}
    speaker_times_str = ", ".join([f"{k}={v}" for k, v in speaker_times.items()]) if speaker_times else ""

    header = [
        program_line,
        f"{L['author']}: {author_line}".strip(),
        f"{L['processed']}: {data.get('datetime','')}".strip(),
        f"{L['file']}: {data.get('audio_file','')} ({data.get('audio_duration','')}, {data.get('audio_specs','')})".strip(),
        f"{L['whisper']}: {data.get('whisper_model','')} | {L['lang']}: {data.get('language','')} | {L['pyannote']}: {data.get('pyannote_model','')}".strip(),
        f"{L['speakers']}: {data.get('speakers_count','')} | {L['segments']}: {data.get('segments_count','')} | {L['talk']}: {speaker_times_str}".strip(),
        f"{L['export']}: {'/'.join([str(x).upper() for x in (data.get('export_formats') or data.get('formats') or ['TXT','PDF','HTML'])])}".strip(),
        "",
        section_title,
    ]

    transcript_lines = _lines_from_transcript(data.get("transcript"))
    non_verbal = data.get("non_verbal") or []
    if isinstance(non_verbal, str):
        non_verbal = [ln.strip() for ln in non_verbal.splitlines() if ln.strip()]

    out = "\n".join(header) + "\n"
    if transcript_lines:
        out += "\n".join(transcript_lines) + "\n"
    else:
        out += "(brak)\n"

    if non_verbal:
        out += "\n" + f"{L['nonverbal']}: " + ", ".join([f"[{x}]" for x in non_verbal]) + "\n"

    if logs and data.get("logs"):
        out += "\n" + L["logs"] + "\n"
        out += str(data.get("logs")) + "\n"

    # Attribution/footer (explicitly requested)
    lic = (data.get("license_name") or DEFAULT_LICENSE_NAME).strip()
    out += "\n" + f"{L['generated']}: {program_line} • {L['author']}: {author_line} • {L['license']}: {lic} • AS IS" + "\n"

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(out)
