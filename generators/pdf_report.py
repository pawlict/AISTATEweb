from __future__ import annotations

import datetime as dt
import os
import re
from dataclasses import asdict
from typing import Any, Dict, List, Optional, Tuple


DEFAULT_PROGRAM = "AISTATEwww"
DEFAULT_AUTHOR_EMAIL = "pawlict@proton.me"
DEFAULT_LICENSE_NAME = "MIT License (AS IS)"


# --- Minimal timestamp/speaker parser (no Qt deps) ---
_TS_BRACKET_RE = re.compile(r"\[(?P<a>[0-9:.,]+)\s*[-–]\s*(?P<b>[0-9:.,]+)\]")
_SPK_PREFIX_RE = re.compile(r"^(?P<spk>[^:\[\]]{1,64}):\s*(?P<rest>.*)$")
_SPK_AFTER_TS_RE = re.compile(r"^\s*(?P<spk>[^:\[\]]{1,64}):\s*(?P<txt>.*)$")


def _safe_basename(path: Optional[str]) -> str:
    if not path:
        return "(brak)"
    try:
        return os.path.basename(path)
    except Exception:
        return str(path)


def _truncate(text: str, max_chars: int) -> Tuple[str, bool]:
    """Return (maybe_truncated_text, was_truncated)."""
    t = text or ""
    if max_chars <= 0 or len(t) <= max_chars:
        return t, False
    return t[: max_chars - 1] + "…", True


def _parse_time_to_seconds(s: str) -> Optional[float]:
    s = (s or "").strip().replace(",", ".")
    if not s:
        return None
    # float seconds format
    if re.fullmatch(r"\d+(?:\.\d+)?", s):
        try:
            return float(s)
        except Exception:
            return None
    # HH:MM:SS(.ms)
    m = re.fullmatch(r"(?P<h>\d{1,2}):(?P<m>\d{2}):(?P<sec>\d{2})(?:\.(?P<ms>\d{1,3}))?", s)
    if not m:
        return None
    h = int(m.group("h"))
    mi = int(m.group("m"))
    sec = int(m.group("sec"))
    ms_s = (m.group("ms") or "0").ljust(3, "0")[:3]
    ms = int(ms_s)
    return float(h * 3600 + mi * 60 + sec) + ms / 1000.0


def _extract_segments(diarized_text: str) -> Tuple[int, List[str]]:
    """Return (segment_count, speakers_list)."""
    seg_count = 0
    speakers: List[str] = []
    for line in (diarized_text or "").splitlines():
        raw = (line or "").strip()
        if not raw:
            continue

        speaker = ""
        rest = raw

        # speaker before timestamp
        m0 = _SPK_PREFIX_RE.match(rest)
        if m0 and _TS_BRACKET_RE.search(m0.group("rest") or ""):
            speaker = (m0.group("spk") or "").strip()
            rest = (m0.group("rest") or "").strip()

        m = _TS_BRACKET_RE.search(rest)
        if not m:
            continue

        a = _parse_time_to_seconds(m.group("a"))
        b = _parse_time_to_seconds(m.group("b"))
        if a is None or b is None:
            continue

        after = (rest[m.end() :] or "").strip()
        if not speaker and after:
            m1 = _SPK_AFTER_TS_RE.match(after)
            if m1:
                speaker = (m1.group("spk") or "").strip()

        seg_count += 1
        if speaker and speaker not in speakers:
            speakers.append(speaker)

    return seg_count, speakers



def _labels(ui_lang: str) -> Dict[str, str]:
    ui_lang = (ui_lang or "pl").lower()
    if ui_lang.startswith("en"):
        return {
            "author": "Author",
            "processed": "Processed",
            "file": "File",
            "models": "Models",
            "speakers": "Speakers",
            "segments": "Segments",
            "talk": "Talk time",
            "export": "Export format",
            "diary": "Diarization",
            "transcript_in": "Transcript (input)",
            "logs": "Logs",
            "note_cut": "(Note: content was truncated in the report)",
            "nonverbal": "Non-verbal",
            "language": "Language",
            "generated": "Generated by",
            "license": "License",
        }
    return {
        "author": "Autor",
        "processed": "Przetworzono",
        "file": "Plik",
        "models": "Modele",
        "speakers": "Liczba speakerów",
        "segments": "Segmenty",
        "talk": "Czas mówienia",
        "export": "Format eksportu",
        "diary": "Diaryzacja",
        "transcript_in": "Transkrypcja (wejście)",
        "logs": "Logi",
        "note_cut": "(Uwaga: zawartość została skrócona w raporcie)",
        "nonverbal": "Non-verbal",
        "language": "Język",
        "generated": "Wygenerowano przez",
        "license": "Licencja",
    }


def html_escape(s: str) -> str:
    # ReportLab Paragraph supports a small HTML-like subset; escape everything.
    return (
        (s or "")
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&#39;")
    )


def _parse_diarized_line(line: str) -> Tuple[Optional[float], Optional[float], str, str]:
    """
    Best-effort parser:
    [a-b] SPEAKER_00 [TAG]: text...
    [a-b] SPEAKER_00: text...
    """
    s = (line or "").strip()
    if not s:
        return None, None, "", ""

    m = _TS_BRACKET_RE.search(s)
    t0 = t1 = None
    rest = s
    if m:
        t0 = _parse_time_to_seconds(m.group("a"))
        t1 = _parse_time_to_seconds(m.group("b"))
        # remove bracket part from line
        rest = (s[m.end() :]).strip()

    # speaker is usually at beginning now
    spk = ""
    txt = rest
    m2 = _SPK_AFTER_TS_RE.match(rest)
    if m2:
        spk = (m2.group("spk") or "").strip()
        txt = (m2.group("txt") or "").strip()

    return t0, t1, spk, txt


def _register_unicode_fonts():
    """
    ReportLab base fonts don't support Polish diacritics.
    Register DejaVu Sans + Mono from common locations (Kali/Debian) or project assets.
    """
    try:
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
    except Exception:
        return None, None

    candidates_sans = [
        os.path.join(os.path.dirname(__file__), "..", "assets", "fonts", "DejaVuSans.ttf"),
        "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
        "/usr/share/fonts/TTF/DejaVuSans.ttf",
    ]
    candidates_mono = [
        os.path.join(os.path.dirname(__file__), "..", "assets", "fonts", "DejaVuSansMono.ttf"),
        "/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf",
        "/usr/share/fonts/TTF/DejaVuSansMono.ttf",
    ]

    def pick(paths):
        for p in paths:
            try:
                if p and os.path.exists(p):
                    return p
            except Exception:
                continue
        return None

    sans_path = pick(candidates_sans)
    mono_path = pick(candidates_mono)

    sans_name = None
    mono_name = None
    try:
        if sans_path:
            sans_name = "DejaVuSans"
            pdfmetrics.registerFont(TTFont(sans_name, sans_path))
        if mono_path:
            mono_name = "DejaVuSansMono"
            pdfmetrics.registerFont(TTFont(mono_name, mono_path))
    except Exception:
        sans_name = None
        mono_name = None

    return sans_name, mono_name


def generate_pdf_report(data: Dict[str, Any], logs: bool = False, output_path: str = "") -> None:
    """
    Generate a styled PDF report with Unicode (PL chars) support and stable layout.
    """
    # Local import so the app can start without reportlab.
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import mm
    from reportlab.platypus import (
        SimpleDocTemplate,
        Paragraph,
        Spacer,
        Table,
        TableStyle,
        Preformatted,
        PageBreak,
    )
    from reportlab.lib import colors

    ui_lang = str(data.get("ui_language") or data.get("lang_ui") or "pl")
    L = _labels(ui_lang)

    section_title = (data.get("section_title") or data.get("report_section_title") or "").strip()
    if not section_title:
        section_title = str(L["diary"])

    # Timestamp (CET/Warsaw) if adapter didn't provide one
    try:
        from zoneinfo import ZoneInfo
        now = dt.datetime.now(ZoneInfo("Europe/Warsaw"))
        now_str = now.strftime("%Y-%m-%d %H:%M CET")
    except Exception:
        now = dt.datetime.now().astimezone()
        now_str = now.strftime("%Y-%m-%d %H:%M")

    app_name = str(data.get("program_name") or DEFAULT_PROGRAM)
    app_version = str(data.get("version") or "")
    author = str(data.get("author") or DEFAULT_AUTHOR_EMAIL)
    processed = str(data.get("datetime") or now_str)

    license_name = str(data.get("license_name") or DEFAULT_LICENSE_NAME)

    lic = str(data.get("license_name") or DEFAULT_LICENSE_NAME)

    audio_file = str(data.get("audio_file") or "")
    audio_duration = str(data.get("audio_duration") or "")
    audio_specs = str(data.get("audio_specs") or "")

    whisper_model = str(data.get("whisper_model") or "")
    language = str(data.get("language") or "")
    pyannote_model = str(data.get("pyannote_model") or "")

    speakers_count = str(data.get("speakers_count") or "")
    segments_count = str(data.get("segments_count") or "")
    speaker_times = data.get("speaker_times") or {}
    speaker_times_str = ", ".join([f"{k}={v}" for k, v in speaker_times.items()]) if speaker_times else ""

    export_formats = data.get("export_formats") or data.get("formats") or ["TXT", "PDF", "HTML"]
    export_str = "/".join([str(x).upper() for x in export_formats])

    diar_lines = data.get("transcript") or []
    if isinstance(diar_lines, str):
        diar_lines = [ln for ln in diar_lines.splitlines() if ln.strip()]

    transcript_in = data.get("transcript_in") or data.get("raw_transcript") or data.get("input_transcript") or ""
    logs_text = str(data.get("logs") or "")

    # Fonts
    sans_name, mono_name = _register_unicode_fonts()
    base_sans = sans_name or "Helvetica"
    base_mono = mono_name or base_sans

    styles = getSampleStyleSheet()
    # Set default fonts for existing styles
    for k in ("Title", "Heading1", "Heading2", "BodyText", "Normal"):
        if k in styles:
            styles[k].fontName = base_sans

    title_style = styles["Title"]
    h1_style = styles["Heading1"]
    h2_style = styles["Heading2"]
    body_style = styles["BodyText"]

    small_style = ParagraphStyle(
        "Small",
        parent=styles["BodyText"],
        fontName=base_sans,
        fontSize=9,
        leading=11,
        textColor=colors.HexColor("#111111"),
    )
    mono_style = ParagraphStyle(
        "Mono",
        parent=styles["BodyText"],
        fontName=base_mono,
        fontSize=8.5,
        leading=10.5,
    )

    # Document and widths
    doc = SimpleDocTemplate(
        output_path,
        pagesize=A4,
        rightMargin=16 * mm,
        leftMargin=16 * mm,
        topMargin=14 * mm,
        bottomMargin=14 * mm,
        title=f"{app_name} {app_version}".strip(),
    )
    page_w, _page_h = A4
    content_w = page_w - doc.leftMargin - doc.rightMargin

    def on_page(canvas, _doc):
        canvas.saveState()
        canvas.setFont(base_sans, 8)
        canvas.setFillColor(colors.grey)
        footer_left = f"{L['generated']}: {app_name} {app_version}".strip()
        footer_left += f" | {L['author']}: {author}"
        footer_left += f" | {L['license']}: {license_name} | AS IS"
        canvas.drawString(doc.leftMargin, 10 * mm, footer_left)
        canvas.drawRightString(page_w - doc.rightMargin, 10 * mm, f"{_doc.page}")
        canvas.restoreState()

    story: List[Any] = []

    # ===== Meta "card" =====
    meta_title = f"{app_name} {app_version}".strip()
    file_line = audio_file
    if audio_duration or audio_specs:
        parts = []
        if audio_duration:
            parts.append(audio_duration)
        if audio_specs:
            parts.append(audio_specs)
        file_line = f"{audio_file} ({', '.join(parts)})".strip()

    models_line = f"Whisper: {whisper_model} | {L['language']}: {language} | pyannote: {pyannote_model}"

    meta_rows = [
        [Paragraph(f"<b>{html_escape(meta_title)}</b>", body_style)],
        [Paragraph(f"{html_escape(L['author'])}: {html_escape(author)}", body_style)],
        [Paragraph(f"{html_escape(L['processed'])}: {html_escape(processed)}", body_style)],
        [Paragraph(f"{html_escape(L['file'])}: {html_escape(file_line)}", body_style)],
        [Paragraph(f"{html_escape(L['models'])}: {html_escape(models_line)}", body_style)],
        [Paragraph(f"{html_escape(L['speakers'])}: {html_escape(speakers_count)}", body_style)],
        [Paragraph(f"{html_escape(L['segments'])}: {html_escape(segments_count)} &nbsp;&nbsp;|&nbsp;&nbsp; {html_escape(L['talk'])}: {html_escape(speaker_times_str)}", body_style)],
        [Paragraph(f"{html_escape(L['export'])}: {html_escape(export_str)}", body_style)],
        [Paragraph(f"{html_escape(L['license'])}: {html_escape(license_name)} &nbsp;&nbsp;|&nbsp;&nbsp; AS IS", body_style)],
    ]
    meta_tbl = Table(meta_rows, colWidths=[content_w])
    meta_tbl.setStyle(
        TableStyle(
            [
                ("BOX", (0, 0), (-1, -1), 0.6, colors.lightgrey),
                ("BACKGROUND", (0, 0), (-1, -1), colors.white),
                ("LEFTPADDING", (0, 0), (-1, -1), 10),
                ("RIGHTPADDING", (0, 0), (-1, -1), 10),
                ("TOPPADDING", (0, 0), (-1, -1), 7),
                ("BOTTOMPADDING", (0, 0), (-1, -1), 7),
            ]
        )
    )
    story.append(meta_tbl)
    story.append(Spacer(1, 10))

    # ===== Main section =====
    story.append(Paragraph(html_escape(section_title), ParagraphStyle("DiaryTitle", parent=h1_style, fontSize=18, leading=22)))
    story.append(Spacer(1, 6))

    segments = []
    for ln in diar_lines:
        t0, t1, spk, txt = _parse_diarized_line(str(ln))
        segments.append((t0, t1, spk, txt))

    palette = [
        (colors.HexColor("#eaf2ff"), colors.HexColor("#bfd6ff")),  # blue
        (colors.HexColor("#eaf7ee"), colors.HexColor("#bfe6c8")),  # green
        (colors.HexColor("#fff1e6"), colors.HexColor("#ffd1ad")),  # orange
        (colors.HexColor("#f3eaff"), colors.HexColor("#d9c7ff")),  # violet
        (colors.HexColor("#e9fbff"), colors.HexColor("#bfeef7")),  # cyan
        (colors.HexColor("#fff0f6"), colors.HexColor("#ffc2dd")),  # pink
    ]
    speakers_seen: List[str] = []
    for _, _, spk, _ in segments:
        if spk and spk not in speakers_seen:
            speakers_seen.append(spk)

    def spk_colors(spk: str):
        if not spk:
            return palette[0]
        idx = speakers_seen.index(spk) if spk in speakers_seen else 0
        return palette[idx % len(palette)]

    for t0, t1, spk, txt in segments:
        ts = ""
        if t0 is not None and t1 is not None:
            ts = f"[{t0:.2f}-{t1:.2f}]"
        elif t0 is not None:
            ts = f"[{t0:.2f}-?]"

        # Wrapable paragraph; stable layout
        line1 = f"{ts} {spk}:".strip()
        seg_para = Paragraph(
            f"<b>{html_escape(line1)}</b> {html_escape(txt)}",
            small_style,
        )

        bg, border = spk_colors(spk)
        seg_tbl = Table([[seg_para]], colWidths=[content_w])
        seg_tbl.setStyle(
            TableStyle(
                [
                    ("BOX", (0, 0), (-1, -1), 0.8, border),
                    ("BACKGROUND", (0, 0), (-1, -1), bg),
                    ("LEFTPADDING", (0, 0), (-1, -1), 10),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 10),
                    ("TOPPADDING", (0, 0), (-1, -1), 7),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 7),
                ]
            )
        )
        story.append(seg_tbl)
        story.append(Spacer(1, 4))

    # Non-verbal
    non_verbal = data.get("non_verbal") or []
    if isinstance(non_verbal, str):
        non_verbal = [ln.strip() for ln in non_verbal.splitlines() if ln.strip()]
    if non_verbal:
        nv = " ".join([f"[{x}]" for x in non_verbal])
        story.append(Spacer(1, 6))
        story.append(Paragraph(f"<b>{html_escape(L['nonverbal'])}:</b> {html_escape(nv)}", body_style))

    # Transcript input (optional)
    if transcript_in:
        story.append(PageBreak())
        story.append(Paragraph(html_escape(L["transcript_in"]), h2_style))
        story.append(Spacer(1, 6))
        t, cut = _truncate(str(transcript_in), 18000)
        if cut:
            story.append(Paragraph(html_escape(L["note_cut"]), body_style))
        story.append(Preformatted(t, mono_style))

    # Logs (optional)
    if logs:
        story.append(PageBreak())
        story.append(Paragraph(html_escape(L["logs"]), h2_style))
        story.append(Spacer(1, 6))
        t, cut = _truncate(logs_text or "(brak)", 18000)
        if cut:
            story.append(Paragraph(html_escape(L["note_cut"]), body_style))
        story.append(Preformatted(t, mono_style))

    doc.build(story, onFirstPage=on_page, onLaterPages=on_page)
